# 数据结构与算法面试宝典

## 一、栈 Stack

栈是一种后进先出 **(Last In First Out, LIFO)** 的数据结构，在 Python 中可以通过内置的 `list` 实现。

### 1.1 匹配字符串括号

**问题描述：**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 $s$ ，判断字符串是否有效。

**代码：**

```python
class Solution:
    def isValid(self, s: str) -> bool:
        # 边界条件，如果字符串为空或者长度为奇数，则返回 False
        if not s or len(s) % 2 != 0:
            return False
        
        # 初始化一个 stack
        stack = []
        # 定义一个字典，用于存储括号对
        bracket_dict = {')': '(', '}': '{', ']': '['}
        # 遍历字符串
        for char in s:
            # 如果是左括号，则入栈
            if char in "([{":
                stack.append(char)
            # 如果是右括号，则判断栈顶元素是否匹配
            else:
                # 如果不是空栈，且最后一个元素匹配，则出栈
                if stack and stack[-1] == bracket_dict[char]:
                    stack.pop()
                else:
                    return False
                
        # 如果栈为空，则说明所有括号都匹配
        return not stack
```

### 1.2 大鱼吃小鱼

**问题描述：**在水中有许多的鱼，可以认为这些鱼停放在x轴上。给定两个数组 $Size$，$Dir$，$Size[i]$ 表示第 $i$ 条鱼的大小，$Dir[i]$ 表示鱼的方向 (`0` 表示向左游，`1` 表示向右游)。这两个数组分别表示鱼的大小和游动的方向，并且这两个数组的长度相等。

这些鱼的行为都符合以下几个条件:

1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离
2. 当方向相对时，大鱼会吃掉小鱼
3. 鱼的大小都不一样

请计算还剩下几条鱼?

**代码：**

```python
class Solution:
    def fish(self, size: List[int], direction: List[int]) -> int:
        # 边界条件，如果只有一条鱼，则返回鱼的数量
        if len(size) <= 1:
            return len(size)

        # 初始化栈
        stack = []

        # 遍历每条鱼
        for i in range(len(size)):
            curr_size, curr_dir = size[i], direction[i]

            if curr_dir == 1:
                # 如果当前鱼向右游动，则直接入栈
                stack.append((curr_size, curr_dir))
            else:  # 向左游，可能与栈顶鱼相遇
                while stack and stack[-1][1] == 1:  # 栈顶鱼向右
                    if stack[-1][0] > curr_size:  # 栈顶鱼更大，当前鱼被吃
                        break
                    else:  # 当前鱼更大，吃掉栈顶鱼
                        stack.pop()
                else:  # 栈空或栈顶鱼向左，当前鱼存活
                    stack.append((curr_size, curr_dir))

        return len(stack)
```

### 1.3 单调栈问题

**问题描述：**给一个整数数组 $nums$，找到每个元素：右边第一个比自身小的下标位置，没有则用 `-1` 表示

**代码：**

```python
class Solution:
    def findRightSmall(self, nums: List[int]) -> List[int]:
        # 边界条件
        if not nums:
            return []
        
        # 初始化栈
        stack = []
        
        # 初始化结果
        res = [-1] * len(nums)

        # 遍历数组
        for i in range(len(nums)):
            # 如果栈不为空，且当前元素小于栈顶元素，则更新结果
            while stack and nums[i] < nums[stack[-1]]:
                res[stack.pop()] = i
            # 将当前元素下标入栈
            stack.append(i)

        return res
```

**解决单调栈问题的一般思路：**

|            **问题特征**             | **适用栈类型** |                **例子**                 |
| :---------------------------------: | :------------: | :-------------------------------------: |
|   找 **更大元素**（Next Greater）   |     递减栈     |     `[2,1,2,4,3]`→ `[4,2,4,-1,-1]`      |
|   找 **更小元素**（Next Smaller）   |     递增栈     |     `[2,1,2,4,3]`→ `[1,-1,-1,3,-1]`     |
| 找 **左侧更大元素**（Left Greater） |     递减栈     |     `[2,1,2,4,3]`→ `[-1,2,-1,-1,4]`     |
| 找 **左侧更小元素**（Left Smaller） |     递增栈     |     `[2,1,2,4,3]`→ `[-1,-1,1,2,2]`      |
|       计算 **直方图最大面积**       |     递增栈     |       `[2,1,5,6,2,3]`→ 面积 `10`        |
| 解决 **方向性问题**（如大鱼吃小鱼） | 递减栈（变种） | `Size=[4,2,5], Dir=[1,0,0]`→ 存活 `[5]` |

> - **递增栈**：用于找 **更小的元素** 或 **计算受较小元素限制的问题**（如直方图面积）。
> - **递减栈**：用于找 **更大的元素** 或 **计算受较大元素限制的问题**（如下一个更大元素）。
> - **方向性问题**：结合方向判断（如大鱼吃小鱼），通常用递减栈的变种。

## 二、队列 Queue

队列是一种先入先出**（First In First Out, FIFO）**的数据结构，在 Python 中可以通过内置的 `collections.deque` 实现。

### 2.1 二叉树的层序遍历

**问题描述：** 给定一个二叉树，返回其按层次遍历的节点值（即逐层从左到右遍历）。

**代码：**

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        # 边界条件
        if not root:
            return []

        # 初始化队列
        queue = deque([root])
        res = []

        while queue:
            # 当前层的节点数
            size = len(queue)
            # 存储当前层的节点值
            level = []
            for _ in range(size):
                # 弹出当前层的节点
                node = queue.popleft()
                # 将当前节点的值加入当前层的节点值列表
                level.append(node.val)
                
                # 将当前节点的左右子节点加入队列
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            # 将当前层的节点值列表加入结果列表
            res.append(level)
            
        return res
```

### 2.2 循环队列

**问题描述：**实现一个循环队列，支持以下操作：

- 入队：将一个元素添加到队列的末尾。
- 出队：从队列的头部移除一个元素。
- 获取队首元素：返回队列的头部元素。
- 获取队尾元素：返回队列的尾部元素。
- 判断队列是否为空：如果队列为空，返回 True；否则，返回 False。
- 判断队列是否已满：如果队列已满，返回 True；否则，返回 False。

**代码：**

```python
class MyCircularQueue:
    def __init__(self, size):
        self.size = size + 1
        self.queue = [None] * self.size
        self.front = 0
        self.rear = 0
        
    def is_empty(self):
        """判断队列是否为空"""
        return self.front == self.rear
    
    def is_full(self):
        """判断队列是否已满"""
        return (self.rear + 1) % self.size == self.front
    
    def enqueue(self, value):
        """入队操作"""
        if self.is_full():  
            raise Exception("Queue is full")
        else:
            self.rear = (self.rear + 1) % self.size
            self.queue[self.rear] = value

    def dequeue(self):
        """出队操作"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_front(self):
        """获取队首元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_rear(self):
        """获取队尾元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            return self.queue[self.rear]
```

### 2.3 滑动窗口的最大值（单调队列）

**问题描述：**给定一个数组 $nums$ 和滑动窗口的大小 $k$，请找出所有滑动窗口里的最大值。

**代码：**

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if not nums or k <= 0:
            return []
        
        # 初始化双端队列（利用单调队列）
        dq = deque()
        res = []
        
        for i in range(len(nums)):
            # 移除超出窗口范围的元素
            while dq and dq[0] <= i - k:
                dq.popleft()
                
            # 维护递减队列
            while dq and nums[dq[-1]] < nums[i]:
                dq.pop()
                
            dq.append(i)
            
            # 记录当前窗口最大值
            if i >= k - 1:
                res.append(nums[dq[0]])
                
        return res
```

> **单调队列**是一种特殊的队列，其元素始终保持单调递增或递减的顺序。常用于维护滑动窗口的最值问题，能在 $O(1)$ 时间内获取当前窗口的最值。

## 三、优先队列 Priority Queue

优先队列通过堆来实现，堆是一种特殊的完全二叉树，分为大根堆和小根堆。

- **大根堆：**每个节点的值都大于或等于其子节点的值。
- **小根堆：**每个节点的值都小于或等于其子节点的值。

在 Python 中可以通过 `heapq` 来实现小根堆，如果需要实现大根堆可以通过取负的方法来达到大根堆的效果。

### 3.1 最小的 k 个数

**问题描述：** 给定一个数组 $nums$，找出其中最小的 $k$ 个数。

**代码：**

```python
class Solution:
    def getLeastNumbers(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if k == 0:
            return []
        if not nums:
            return []
        if k >= len(nums):
            return nums

        # 使用堆排序
        max_heap = []
        for num in nums:
            if len(max_heap) < k:
                heapq.heappush(max_heap, -num)
            else:
                if -num > max_heap[0]:
                    heapq.heappop(max_heap)
                    heapq.heappush(max_heap, -num)
                    
        # 将堆中的负数转换回正数
        return [-num for num in max_heap]
```

### 3.2 跳跃游戏

**问题描述：**  假设你正在玩跳跃游戏，从低处往高处跳的时候，可以有两种方法：

- 方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。
- 方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的（一个只能用一次）。

其他无论是平着跳，还是从高处往低处跳，不需要借助什么就可以完成。

给你一个数组 $heights$，用来表示不同的高度。假设你总是站在 `index=0` 的高度开始。那么请问，你最远能跳到哪里？

**代码：**

```python
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, landers: int) -> int:
        # 边界条件
        if not heights:
            return -1
        
        # 初始化最大堆
        max_heap = []
        for i in range(len(heights) - 1):
            diff = heights[i + 1] - heights[i]
            if diff <= 0:
                continue
            
            # 使用梯子优先处理最大的高度差
            if landers > 0:
                heapq.heappush(max_heap, diff)
                landers -= 1
            else:
                # 如果没有梯子，尝试用砖块
                if max_heap and diff > max_heap[0]:
                    # 当前高度差比堆顶大，替换堆顶的高度差用砖块处理
                    smaller_ladder = heapq.heappop(max_heap)
                    if bricks >= smaller_ladder:
                        bricks -= smaller_ladder
                        heapq.heappush(max_heap, diff)
                        
                    else:
                        return i
                else:
                    # 当前高度差比堆顶小，或者堆为空，用砖块处理
                    if bricks >= diff:
                        bricks -= diff
                    else:
                        return i

        return len(heights) - 1
```

### 3.3 汽车加油次数

**问题描述：** 一辆汽车携带 `startFuel` 升汽油从位置 `0` 出发前往位置 `target`，按顺序有一系列加油站 `stations`。

第 `i` 个加油站位于 `stations[i][0]`，可以加 `stations[i][1]` 升油（一个加油站只能加一次）。

如果想要到达 `target`，输出最少加油次数。如果不能到达 `target`，那么返回 `-1`。

同时满足两个条件：

1. 假设汽车油箱总是很大
2. 假设行走一单位距离，消耗一升汽油

**代码：**

```python
class Solution:
    def minRefuelStops(
        self, 
        target: int, 
        startFuel: int, 
        stations: List[List[int]]
    ) -> int:
        # 边界条件1：初始油量足够直接到达目标        
        if startFuel >= target:
            return 0
        
        # 边界条件2：没有加油站且初始油量不足
        if not stations:
            return -1
        
        # 初始化优先队列，存储油量
        max_heap = []
        curr_fuel = startFuel
        curr_pos = 0
        res = 0
        
        # 处理所有加油站
        for pos, fuel in stations + [[target, 0]]:
            # 边界条件3：忽略超过目标的加油站
            if pos > target:
                continue

            dist = pos - curr_pos
            # 油量不足以到达下一个位置时，从堆中取油
            while curr_fuel < dist:
                # 边界条件4：无油可加且无法到达
                if not max_heap:
                    return -1
                curr_fuel += -heapq.heappop(max_heap)
                res += 1

            # 将当前加油站油量加入堆中
            curr_fuel -= dist
            curr_pos = pos
            heapq.heappush(max_heap, -fuel)

        return res if curr_pos == target else -1
```

## 四、链表 Linked List

链表是一种线性数据结构，由一系列 **节点（Node）**组成，每个节点包含：

- **数据域**：存储数据（如整数、字符串等）。
- **指针域**：指向下一个节点的地址（或前一个节点，如果是双向链表）。

**解决链表问题的常用方法：** 

1. **双指针技巧：** 
   1. 快慢指针：判断环形链表、找中间节点、倒数第 k 个节点。
   2. 前后指针：反转链表、删除倒数第 N 个节点。
2. **递归法：** 反向操作（如反转链表）、分治问题（如合并有序链表）。
3. **虚拟头节点：** 简化边界处理（如删除链表中指定值的节点）

### 4.1 链表反转

**问题描述：** 给定单链表的头节点 `head`，反转链表，并返回反转后的链表的头节点。

**代码：**

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return head

        # 初始化指针
        prev, curr = None, head

        # 遍历链表
        while curr:
            # 保存当前节点的下一个节点
            next_node = curr.next
            # 将当前节点的 next 指针指向前一个节点
            curr.next = prev 
            # 将前一个节点移动到当前节点
            prev = curr
            # 将当前节点移动到下一个节点
            curr = next_node

        # 返回反转后的链表头节点
        return prev
```

### 4.2 删除链表中指定值的节点

**问题描述：**给定单向链表的头指针 `head` 和一个要删除的节点的值 `val`，定义一个函数删除该节点。返回删除后的链表的头节点。

**代码：**

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head

        # 创建哑节点
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        
        # 遍历链表
        while curr.next:
            # 如果当前节点的下一个节点的值等于 val
            if curr.next.val == val:
                # 删除下一个节点
                curr.next = curr.next.next
            else:
                curr = curr.next

        return dummy.next
```

### 4.3 链表的倒数第 k 个节点

**问题描述：** 给定一个链表，删除链表中的倒数第 $k$ 个节点。

**代码：**

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head
        
        # 创建一个 dummy
        dummy = ListNode(0)
        dummy.next = head
        
        # 快慢指针
        slow = fast = dummy
        
        # 快指针先走 k 步
        for _ in range(k + 1):
            fast = fast.next

        # 快慢指针同时走，直到快指针到达链表末尾
        while fast.next:
            slow = slow.next
            fast = fast.next

        # 删除倒数第 k 个节点
        slow.next = slow.next.next

        return head
```

### 4.4 链表环问题

**问题描述：** 给你一个链表的头节点 `head` ，判断链表中是否有环。如果有环，请找出环的入口节点。

**代码：**

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return None
        
        # 快慢指针
        slow = fast = head
        # 记录是否存在环
        has_cycle = False

        # 使用快慢指针法判断是否存在环
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        # 如果不存在环，则返回
        if not has_cycle:
            return None
        
        # 如果存在环，则找到环的入口节点
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

## 五、二叉树 Binary Tree

**二叉树**是一种重要的数据结构，每个节点最多有两个子节点（左子节点和右子节点）。二叉树存在一些基本概念：

- **节点（Node）**：存储数据的基本单位，包含：
  - **数据域（val）**：存储值。
  - **左指针（left）**：指向左子节点。
  - **右指针（right）**：指向右子节点。
- **根节点（Root）**：树的起点，没有父节点。
- **叶子节点（Leaf）**：没有子节点的节点。
- **深度（Depth）**：从根到该节点的最长路径的边数。
- **高度（Height）**：从该节点到最深叶子节点的最长路径的边数（通常根的高度最大）。
- **度（Degree）**：节点的子节点数（二叉树中最大为2）。

### 5.1 二叉树的遍历

二叉树遍历是指按照某种顺序访问树的所有节点，主要分为 **深度优先遍历（DFS）** 和 **广度优先遍历（BFS）**。每种遍历方式有不同的应用场景。

| 遍历方式 |   顺序   | 递归 | 迭代（栈/队列） |      应用场景      |
| :------: | :------: | :--: | :-------------: | :----------------: |
| **前序** | 根→左→右 |  ✅   |     ✅（栈）     |   复制树、序列化   |
| **中序** | 左→根→右 |  ✅   |     ✅（栈）     |    BST 有序输出    |
| **后序** | 左→右→根 |  ✅   |  ✅（栈+反转）   | 删除树、表达式求值 |
| **层序** | 按层遍历 |  ❌   |    ✅（队列）    |  求高度、最短路径  |

**代码：** 层序遍历的实现在 [2.1 二叉树的层序遍历](###2.1 二叉树的层序遍历) 中展示过

```python
class Solution:
    def preOrder(self, root: Optional[TreeNode]) -> List[int]:
        """前序遍历"""
        # 边界条件
        if not root:
            return []
        
        # 递归
        return [root.val] + self.preOrder(root.left) + self.preOrder(root.right)

    def inOrder(self, root: Optional[TreeNode]) -> List[int]:
        """中序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.inOrder(root.left) + [root.val] + self.inOrder(root.right)

    def postOrder(self, root: Optional[TreeNode]) -> List[int]:
        """后序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.postOrder(root.left) + self.postOrder(root.right) + [root.val]
```

### 5.2 验证二叉搜索树

**问题描述：** 给定一个二叉树，判断其是否是一个有效的二叉搜索树。

**代码：**

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(node, lower=float('-inf'), upper=float('inf')):
            """通过递归判断二叉树是否是二叉搜索树"""
            if not node:
                return True

            # 如果当前节点的值不在合法范围内，则不是二叉搜索树
            val = node.val
            if val <= lower or val >= upper:
                return False

            # 递归判断左子树和右子树
            # 左子树的值一定要小于当前节点的值，
            # 右子树的值一定要大于当前节点的值
            return dfs(node.left, lower, val) and dfs(node.right, val, upper)

        return dfs(root)
```

> **二叉搜索树（Binary Search Tree, BST）**是一种特殊的二叉树，具有高效的查找、插入和删除特性，广泛应用于数据库索引、内存查找等场景。
>
> **BST 性质**：BST 的中序遍历总是生成严格升序序列。
>
> - 左子树所有节点的值 **<** 根节点的值。
> - 右子树所有节点的值 **>** 根节点的值。
> - 左右子树也必须是 BST（递归定义）。

### 5.3 目标和的所有路径

**问题描述：**给定一颗二叉树，一个目标值 $target$。请输出所有路径，需要满足根节点至叶子节点之和等于给定的目标值

**代码：**

```python
class Solution:
    def findTargetSumWays(self, root: Optional[TreeNode], target: int) -> List[List[int]]:
        # 边界条件
        if not root:
            return []
        
        # 用于存储结果
        res = []
        
        def backtrace(
            node: Optional[TreeNode], 
            path: List[int], current_sum: int, target: int
        ):
            """回溯算法"""
            # 终止条件
            if not node:
                return
            
             # 更新当前路径和
            current_sum += node.val
            path.append(node.val)

            # 检查是否是叶子节点且满足条件
            if not node.left and not node.right and current_sum == target:
                res.append(path[:])
            
            # 递归遍历左右子树
            backtrace(node.left, path, current_sum, target)
            backtrace(node.right, path, current_sum, target)
            
            # 回溯
            path.pop()

        backtrace(root, [], 0, target)
        return res
```

### 5.4 删除二叉搜索树的节点

**问题描述：** 删除二叉搜索树的指定节点。返回删除之后的根节点。

**代码：**

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # 边界条件
        if not root:
            return None
        # 如果这个值比根节点小，则从左子树删除
        if val < root.val:
            root.left = self.deleteNode(root.left, val)
        # 如果这个值比根节点大，则从右子树删除
        elif val > root.val:
            root.right = self.deleteNode(root.right, val)
        else:
            # 找到要删除的节点
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                # 左右子树都不为空，找到右子树的最小节点
                successor = root.right
                while successor.left:
                    successor = successor.left
                # 用后继节点的值替换当前节点
                root.val = successor.val
                # 删除后继节点
                root.right = self.deleteNode(root.right, successor.val)
        
        return root
```

## 六、排序

## 七、二分搜索

## 八、双指针

## 九、贪心

## 十、回溯

## 十一、图搜索

## 十二、动态规划



