# 数据结构与算法面试宝典

## 一、栈 Stack

栈是一种后进先出 **(Last In First Out, LIFO)** 的数据结构，在 Python 中可以通过内置的 `list` 实现。

### 1.1 匹配字符串括号

**问题描述：**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 $s$ ，判断字符串是否有效。

**代码：**

```python
class Solution:
    def isValid(self, s: str) -> bool:
        # 边界条件，如果字符串为空或者长度为奇数，则返回 False
        if not s or len(s) % 2 != 0:
            return False
        
        # 初始化一个 stack
        stack = []
        # 定义一个字典，用于存储括号对
        bracket_dict = {')': '(', '}': '{', ']': '['}
        # 遍历字符串
        for char in s:
            # 如果是左括号，则入栈
            if char in "([{":
                stack.append(char)
            # 如果是右括号，则判断栈顶元素是否匹配
            else:
                # 如果不是空栈，且最后一个元素匹配，则出栈
                if stack and stack[-1] == bracket_dict[char]:
                    stack.pop()
                else:
                    return False
                
        # 如果栈为空，则说明所有括号都匹配
        return not stack
```

### 1.2 大鱼吃小鱼

**问题描述：**在水中有许多的鱼，可以认为这些鱼停放在x轴上。给定两个数组 $Size$，$Dir$，$Size[i]$ 表示第 $i$ 条鱼的大小，$Dir[i]$ 表示鱼的方向 (`0` 表示向左游，`1` 表示向右游)。这两个数组分别表示鱼的大小和游动的方向，并且这两个数组的长度相等。

这些鱼的行为都符合以下几个条件:

1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离
2. 当方向相对时，大鱼会吃掉小鱼
3. 鱼的大小都不一样

请计算还剩下几条鱼?

**代码：**

```python
class Solution:
    def fish(self, size: List[int], direction: List[int]) -> int:
        # 边界条件，如果只有一条鱼，则返回鱼的数量
        if len(size) <= 1:
            return len(size)

        # 初始化栈
        stack = []

        # 遍历每条鱼
        for i in range(len(size)):
            curr_size, curr_dir = size[i], direction[i]

            if curr_dir == 1:
                # 如果当前鱼向右游动，则直接入栈
                stack.append((curr_size, curr_dir))
            else:  # 向左游，可能与栈顶鱼相遇
                while stack and stack[-1][1] == 1:  # 栈顶鱼向右
                    if stack[-1][0] > curr_size:  # 栈顶鱼更大，当前鱼被吃
                        break
                    else:  # 当前鱼更大，吃掉栈顶鱼
                        stack.pop()
                else:  # 栈空或栈顶鱼向左，当前鱼存活
                    stack.append((curr_size, curr_dir))

        return len(stack)
```

### 1.3 单调栈问题

**问题描述：**给一个整数数组 $nums$，找到每个元素：右边第一个比自身小的下标位置，没有则用 `-1` 表示

**代码：**

```python
class Solution:
    def findRightSmall(self, nums: List[int]) -> List[int]:
        # 边界条件
        if not nums:
            return []
        
        # 初始化栈
        stack = []
        
        # 初始化结果
        res = [-1] * len(nums)

        # 遍历数组
        for i in range(len(nums)):
            # 如果栈不为空，且当前元素小于栈顶元素，则更新结果
            while stack and nums[i] < nums[stack[-1]]:
                res[stack.pop()] = i
            # 将当前元素下标入栈
            stack.append(i)

        return res
```

**解决单调栈问题的一般思路：**

|            **问题特征**             | **适用栈类型** |                **例子**                 |
| :---------------------------------: | :------------: | :-------------------------------------: |
|   找 **更大元素**（Next Greater）   |     递减栈     |     `[2,1,2,4,3]`→ `[4,2,4,-1,-1]`      |
|   找 **更小元素**（Next Smaller）   |     递增栈     |     `[2,1,2,4,3]`→ `[1,-1,-1,3,-1]`     |
| 找 **左侧更大元素**（Left Greater） |     递减栈     |     `[2,1,2,4,3]`→ `[-1,2,-1,-1,4]`     |
| 找 **左侧更小元素**（Left Smaller） |     递增栈     |     `[2,1,2,4,3]`→ `[-1,-1,1,2,2]`      |
|       计算 **直方图最大面积**       |     递增栈     |       `[2,1,5,6,2,3]`→ 面积 `10`        |
| 解决 **方向性问题**（如大鱼吃小鱼） | 递减栈（变种） | `Size=[4,2,5], Dir=[1,0,0]`→ 存活 `[5]` |

> - **递增栈**：用于找 **更小的元素** 或 **计算受较小元素限制的问题**（如直方图面积）。
> - **递减栈**：用于找 **更大的元素** 或 **计算受较大元素限制的问题**（如下一个更大元素）。
> - **方向性问题**：结合方向判断（如大鱼吃小鱼），通常用递减栈的变种。

## 二、队列 Queue

队列是一种先入先出**（First In First Out, FIFO）**的数据结构，在 Python 中可以通过内置的 `collections.deque` 实现。

### 2.1 二叉树的层序遍历

**问题描述：** 给定一个二叉树，返回其按层次遍历的节点值（即逐层从左到右遍历）。

**代码：**

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        # 边界条件
        if not root:
            return []

        # 初始化队列
        queue = deque([root])
        res = []

        while queue:
            # 当前层的节点数
            size = len(queue)
            # 存储当前层的节点值
            level = []
            for _ in range(size):
                # 弹出当前层的节点
                node = queue.popleft()
                # 将当前节点的值加入当前层的节点值列表
                level.append(node.val)
                
                # 将当前节点的左右子节点加入队列
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            # 将当前层的节点值列表加入结果列表
            res.append(level)
            
        return res
```

### 2.2 循环队列

**问题描述：**实现一个循环队列，支持以下操作：

- 入队：将一个元素添加到队列的末尾。
- 出队：从队列的头部移除一个元素。
- 获取队首元素：返回队列的头部元素。
- 获取队尾元素：返回队列的尾部元素。
- 判断队列是否为空：如果队列为空，返回 True；否则，返回 False。
- 判断队列是否已满：如果队列已满，返回 True；否则，返回 False。

**代码：**

```python
class MyCircularQueue:
    def __init__(self, size):
        self.size = size + 1
        self.queue = [None] * self.size
        self.front = 0
        self.rear = 0
        
    def is_empty(self):
        """判断队列是否为空"""
        return self.front == self.rear
    
    def is_full(self):
        """判断队列是否已满"""
        return (self.rear + 1) % self.size == self.front
    
    def enqueue(self, value):
        """入队操作"""
        if self.is_full():  
            raise Exception("Queue is full")
        else:
            self.rear = (self.rear + 1) % self.size
            self.queue[self.rear] = value

    def dequeue(self):
        """出队操作"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_front(self):
        """获取队首元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_rear(self):
        """获取队尾元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            return self.queue[self.rear]
```

### 2.3 滑动窗口的最大值（单调队列）

**问题描述：**给定一个数组 $nums$ 和滑动窗口的大小 $k$，请找出所有滑动窗口里的最大值。

**代码：**

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if not nums or k <= 0:
            return []
        
        # 初始化双端队列（利用单调队列）
        dq = deque()
        res = []
        
        for i in range(len(nums)):
            # 移除超出窗口范围的元素
            while dq and dq[0] <= i - k:
                dq.popleft()
                
            # 维护递减队列
            while dq and nums[dq[-1]] < nums[i]:
                dq.pop()
                
            dq.append(i)
            
            # 记录当前窗口最大值
            if i >= k - 1:
                res.append(nums[dq[0]])
                
        return res
```

> **单调队列**是一种特殊的队列，其元素始终保持单调递增或递减的顺序。常用于维护滑动窗口的最值问题，能在 $O(1)$ 时间内获取当前窗口的最值。

## 三、优先队列 Priority Queue

优先队列通过堆来实现，堆是一种特殊的完全二叉树，分为大根堆和小根堆。

- **大根堆：**每个节点的值都大于或等于其子节点的值。
- **小根堆：**每个节点的值都小于或等于其子节点的值。

在 Python 中可以通过 `heapq` 来实现小根堆，如果需要实现大根堆可以通过取负的方法来达到大根堆的效果。

### 3.1 最小的 k 个数

**问题描述：** 给定一个数组 $nums$，找出其中最小的 $k$ 个数。

**代码：**

```python
class Solution:
    def getLeastNumbers(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if k == 0:
            return []
        if not nums:
            return []
        if k >= len(nums):
            return nums

        # 使用堆排序
        max_heap = []
        for num in nums:
            if len(max_heap) < k:
                heapq.heappush(max_heap, -num)
            else:
                if -num > max_heap[0]:
                    heapq.heappop(max_heap)
                    heapq.heappush(max_heap, -num)
                    
        # 将堆中的负数转换回正数
        return [-num for num in max_heap]
```

### 3.2 跳跃游戏

**问题描述：**  假设你正在玩跳跃游戏，从低处往高处跳的时候，可以有两种方法：

- 方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。
- 方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的（一个只能用一次）。

其他无论是平着跳，还是从高处往低处跳，不需要借助什么就可以完成。

给你一个数组 $heights$，用来表示不同的高度。假设你总是站在 `index=0` 的高度开始。那么请问，你最远能跳到哪里？

**代码：**

```python
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, landers: int) -> int:
        # 边界条件
        if not heights:
            return -1
        
        # 初始化最大堆
        max_heap = []
        for i in range(len(heights) - 1):
            diff = heights[i + 1] - heights[i]
            if diff <= 0:
                continue
            
            # 使用梯子优先处理最大的高度差
            if landers > 0:
                heapq.heappush(max_heap, diff)
                landers -= 1
            else:
                # 如果没有梯子，尝试用砖块
                if max_heap and diff > max_heap[0]:
                    # 当前高度差比堆顶大，替换堆顶的高度差用砖块处理
                    smaller_ladder = heapq.heappop(max_heap)
                    if bricks >= smaller_ladder:
                        bricks -= smaller_ladder
                        heapq.heappush(max_heap, diff)
                        
                    else:
                        return i
                else:
                    # 当前高度差比堆顶小，或者堆为空，用砖块处理
                    if bricks >= diff:
                        bricks -= diff
                    else:
                        return i

        return len(heights) - 1
```

### 3.3 汽车加油次数

**问题描述：** 一辆汽车携带 `startFuel` 升汽油从位置 `0` 出发前往位置 `target`，按顺序有一系列加油站 `stations`。

第 `i` 个加油站位于 `stations[i][0]`，可以加 `stations[i][1]` 升油（一个加油站只能加一次）。

如果想要到达 `target`，输出最少加油次数。如果不能到达 `target`，那么返回 `-1`。

同时满足两个条件：

1. 假设汽车油箱总是很大
2. 假设行走一单位距离，消耗一升汽油

**代码：**

```python
class Solution:
    def minRefuelStops(
        self, 
        target: int, 
        startFuel: int, 
        stations: List[List[int]]
    ) -> int:
        # 边界条件1：初始油量足够直接到达目标        
        if startFuel >= target:
            return 0
        
        # 边界条件2：没有加油站且初始油量不足
        if not stations:
            return -1
        
        # 初始化优先队列，存储油量
        max_heap = []
        curr_fuel = startFuel
        curr_pos = 0
        res = 0
        
        # 处理所有加油站
        for pos, fuel in stations + [[target, 0]]:
            # 边界条件3：忽略超过目标的加油站
            if pos > target:
                continue

            dist = pos - curr_pos
            # 油量不足以到达下一个位置时，从堆中取油
            while curr_fuel < dist:
                # 边界条件4：无油可加且无法到达
                if not max_heap:
                    return -1
                curr_fuel += -heapq.heappop(max_heap)
                res += 1

            # 将当前加油站油量加入堆中
            curr_fuel -= dist
            curr_pos = pos
            heapq.heappush(max_heap, -fuel)

        return res if curr_pos == target else -1
```

## 四、链表 Linked List

链表是一种线性数据结构，由一系列 **节点（Node）**组成，每个节点包含：

- **数据域**：存储数据（如整数、字符串等）。
- **指针域**：指向下一个节点的地址（或前一个节点，如果是双向链表）。

**解决链表问题的常用方法：** 

1. **双指针技巧：** 
   1. 快慢指针：判断环形链表、找中间节点、倒数第 k 个节点。
   2. 前后指针：反转链表、删除倒数第 N 个节点。
2. **递归法：** 反向操作（如反转链表）、分治问题（如合并有序链表）。
3. **虚拟头节点：** 简化边界处理（如删除链表中指定值的节点）

### 4.1 链表反转

**问题描述：** 给定单链表的头节点 `head`，反转链表，并返回反转后的链表的头节点。

**代码：**

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return head

        # 初始化指针
        prev, curr = None, head

        # 遍历链表
        while curr:
            # 保存当前节点的下一个节点
            next_node = curr.next
            # 将当前节点的 next 指针指向前一个节点
            curr.next = prev 
            # 将前一个节点移动到当前节点
            prev = curr
            # 将当前节点移动到下一个节点
            curr = next_node

        # 返回反转后的链表头节点
        return prev
```

### 4.2 删除链表中指定值的节点

**问题描述：**给定单向链表的头指针 `head` 和一个要删除的节点的值 `val`，定义一个函数删除该节点。返回删除后的链表的头节点。

**代码：**

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head

        # 创建哑节点
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        
        # 遍历链表
        while curr.next:
            # 如果当前节点的下一个节点的值等于 val
            if curr.next.val == val:
                # 删除下一个节点
                curr.next = curr.next.next
            else:
                curr = curr.next

        return dummy.next
```

### 4.3 链表的倒数第 k 个节点

**问题描述：** 给定一个链表，删除链表中的倒数第 $k$ 个节点。

**代码：**

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head
        
        # 创建一个 dummy
        dummy = ListNode(0)
        dummy.next = head
        
        # 快慢指针
        slow = fast = dummy
        
        # 快指针先走 k 步
        for _ in range(k + 1):
            fast = fast.next

        # 快慢指针同时走，直到快指针到达链表末尾
        while fast.next:
            slow = slow.next
            fast = fast.next

        # 删除倒数第 k 个节点
        slow.next = slow.next.next

        return head
```

### 4.4 链表环问题

**问题描述：** 给你一个链表的头节点 `head` ，判断链表中是否有环。如果有环，请找出环的入口节点。

**代码：**

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return None
        
        # 快慢指针
        slow = fast = head
        # 记录是否存在环
        has_cycle = False

        # 使用快慢指针法判断是否存在环
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        # 如果不存在环，则返回
        if not has_cycle:
            return None
        
        # 如果存在环，则找到环的入口节点
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

## 五、二叉树 Binary Tree

**二叉树**是一种重要的数据结构，每个节点最多有两个子节点（左子节点和右子节点）。二叉树存在一些基本概念：

- **节点（Node）**：存储数据的基本单位，包含：
  - **数据域（val）**：存储值。
  - **左指针（left）**：指向左子节点。
  - **右指针（right）**：指向右子节点。
- **根节点（Root）**：树的起点，没有父节点。
- **叶子节点（Leaf）**：没有子节点的节点。
- **深度（Depth）**：从根到该节点的最长路径的边数。
- **高度（Height）**：从该节点到最深叶子节点的最长路径的边数（通常根的高度最大）。
- **度（Degree）**：节点的子节点数（二叉树中最大为2）。

### 5.1 二叉树的遍历

二叉树遍历是指按照某种顺序访问树的所有节点，主要分为 **深度优先遍历（DFS）** 和 **广度优先遍历（BFS）**。每种遍历方式有不同的应用场景。

| 遍历方式 |   顺序   | 递归 | 迭代（栈/队列） |      应用场景      |
| :------: | :------: | :--: | :-------------: | :----------------: |
| **前序** | 根→左→右 |  ✅   |     ✅（栈）     |   复制树、序列化   |
| **中序** | 左→根→右 |  ✅   |     ✅（栈）     |    BST 有序输出    |
| **后序** | 左→右→根 |  ✅   |  ✅（栈+反转）   | 删除树、表达式求值 |
| **层序** | 按层遍历 |  ❌   |    ✅（队列）    |  求高度、最短路径  |

**代码：** 层序遍历的实现在 [2.1 二叉树的层序遍历](###2.1 二叉树的层序遍历) 中展示过

```python
class Solution:
    def preOrder(self, root: Optional[TreeNode]) -> List[int]:
        """前序遍历"""
        # 边界条件
        if not root:
            return []
        
        # 递归
        return [root.val] + self.preOrder(root.left) + self.preOrder(root.right)

    def inOrder(self, root: Optional[TreeNode]) -> List[int]:
        """中序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.inOrder(root.left) + [root.val] + self.inOrder(root.right)

    def postOrder(self, root: Optional[TreeNode]) -> List[int]:
        """后序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.postOrder(root.left) + self.postOrder(root.right) + [root.val]
```

### 5.2 验证二叉搜索树

**问题描述：** 给定一个二叉树，判断其是否是一个有效的二叉搜索树。

**代码：**

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(node, lower=float('-inf'), upper=float('inf')):
            """通过递归判断二叉树是否是二叉搜索树"""
            if not node:
                return True

            # 如果当前节点的值不在合法范围内，则不是二叉搜索树
            val = node.val
            if val <= lower or val >= upper:
                return False

            # 递归判断左子树和右子树
            # 左子树的值一定要小于当前节点的值，
            # 右子树的值一定要大于当前节点的值
            return dfs(node.left, lower, val) and dfs(node.right, val, upper)

        return dfs(root)
```

> **二叉搜索树（Binary Search Tree, BST）**是一种特殊的二叉树，具有高效的查找、插入和删除特性，广泛应用于数据库索引、内存查找等场景。
>
> **BST 性质**：BST 的中序遍历总是生成严格升序序列。
>
> - 左子树所有节点的值 **<** 根节点的值。
> - 右子树所有节点的值 **>** 根节点的值。
> - 左右子树也必须是 BST（递归定义）。

### 5.3 目标和的所有路径

**问题描述：**给定一颗二叉树，一个目标值 $target$。请输出所有路径，需要满足根节点至叶子节点之和等于给定的目标值

**代码：**

```python
class Solution:
    def findTargetSumWays(self, root: Optional[TreeNode], target: int) -> List[List[int]]:
        # 边界条件
        if not root:
            return []
        
        # 用于存储结果
        res = []
        
        def backtrace(
            node: Optional[TreeNode], 
            path: List[int], current_sum: int, target: int
        ):
            """回溯算法"""
            # 终止条件
            if not node:
                return
            
             # 更新当前路径和
            current_sum += node.val
            path.append(node.val)

            # 检查是否是叶子节点且满足条件
            if not node.left and not node.right and current_sum == target:
                res.append(path[:])
            
            # 递归遍历左右子树
            backtrace(node.left, path, current_sum, target)
            backtrace(node.right, path, current_sum, target)
            
            # 回溯
            path.pop()

        backtrace(root, [], 0, target)
        return res
```

### 5.4 删除二叉搜索树的节点

**问题描述：** 删除二叉搜索树的指定节点。返回删除之后的根节点。

**代码：**

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # 边界条件
        if not root:
            return None
        # 如果这个值比根节点小，则从左子树删除
        if val < root.val:
            root.left = self.deleteNode(root.left, val)
        # 如果这个值比根节点大，则从右子树删除
        elif val > root.val:
            root.right = self.deleteNode(root.right, val)
        else:
            # 找到要删除的节点
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                # 左右子树都不为空，找到右子树的最小节点
                successor = root.right
                while successor.left:
                    successor = successor.left
                # 用后继节点的值替换当前节点
                root.val = successor.val
                # 删除后继节点
                root.right = self.deleteNode(root.right, successor.val)
        
        return root
```

## 六、哈希表 Hash Table

哈希表（又称散列表）是一种**基于键值对（Key-Value）存储的高效数据结构**，其核心思想是通过**哈希函数（Hash Function）**将任意类型的键（Key）映射到一个固定范围的整数索引（桶，Bucket），并将值（Value）存储在该索引对应的存储位置中。在 Python 中可以通过内置的 `dict` 类型实现。

哈希表的运行依赖三个核心组件：

1. **哈希函数（Hash Function）**
2. **存储数组（Bucket Array）**
3. **冲突解决机制（Collision Resolution）**

```python
class HashTable:
    def __init__(self, capacity: int, load_factor: float = .75):
        """初始化哈希表"""
        self.capacity = capacity # 底层数组的大小
        self.load_factor = load_factor # 负载因子阈值
        self.size = 0 # 哈希表中元素的数量
        self.buckets = [[] for _ in range(self.capacity)] # 底层数组，每个元素是一个链表

    def _hash(self, key) -> int:
        """哈希函数，将键值映射到索引"""
        return hash(key) % self.capacity
    
    def put(self, key, value) -> None:
        """插入键值对"""
        # 1. 计算桶的索引
        index = self._hash(key)
        bucket = self.buckets[index]

        # 2. 检查键是否已经存在
        for i, (k, v) in enumerate(bucket):
            if k == key:
                # 3. 如果键已经存在，更新值
                bucket[i] = (key, value)
                return

        # 4. 如果键不存在，添加新的键值对
        bucket.append((key, value))
        self.size += 1
        
        # 5. 检查负载因子，如果超过阈值，则扩容
        if self.size / self.capacity > self.load_factor:
            self._resize()
    
    def get(self, key):
        """获取键对应的值"""
        index = self._hash(key)
        bucket = self.buckets[index]

        for k, v in bucket:
            if k == key:
                return v

        # 未找到键
        raise KeyError(f"Key '{key}' not found")
    
    def _resize(self) -> None:
        """扩容哈希表"""
        old_buckets = self.buckets  # 保存旧桶数据
        self.capacity *= 2
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]

        # 将旧桶中的所有键值对重新插入新桶
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)  
                # 复用 put 方法（自动处理哈希和冲突）
```

### 6.1 哈希冲突的解决方法

哈希冲突（Hash Collision）是指**不同的键（Key）通过哈希函数计算后，得到相同的哈希值（索引）**，导致它们被映射到哈希表的同一个桶（Bucket）中。冲突会破坏哈希表的 *O*(1)时间复杂度特性，因此必须通过合理的冲突处理机制来解决。

根据处理思路的不同，冲突处理可分为**开放寻址法**和**链地址法**两大类，此外还有一些变种或优化方法。

1. **开放寻址法（Open Addressing）：** **所有键值对直接存储在桶数组中**，当冲突发生时，通过某种“探测规则”寻找下一个可用的空桶，将冲突的键值对存储在该位置。
   1. **线性探测：**冲突时，从当前桶的下一个位置开始，依次探测后续的桶（索引递增，到数组末尾后循环到开头），直到找到一个空桶。
   2. **二次探测：**冲突时，探测序列为当前索引的二次方偏移。
   3. **双重哈希：**使用两个独立的哈希函数。冲突时，通过第二个哈希函数计算探测步长。
2. **链地址法（Separate Chaining）：** **每个桶存储一个链表（或其他动态数据结构），冲突的键值对被添加到同一桶的链表中**。查找时，先通过哈希函数定位桶，再遍历链表查找目标键。
   1. **链表存储：**每个桶是一个链表（或动态数组），冲突的键值对按顺序添加到链表中。
   2. **链表转树：**当链表长度超过阈值，将链表转换为红黑树（平衡二叉搜索树），将查找时间优化到 $O(\log n)$。

### 6.2 两数之和

**问题描述：** 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**代码：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # {'num': 'index'}
        mapping = defaultdict(int)

        # 遍历数组
        for i, num in enumerate(nums):
            # 计算差值
            diff = target - num
            # 如果差值在字典中，则返回差值的索引和当前索引
            if diff in mapping:
                return [mapping[diff], i]
            # 如果差值不在字典中，则将当前数字和索引存入字典
            mapping[num] = i
            
        return []
```

### 6.3 字母异位词分组

**问题描述：**给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

**代码：**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # 初始化一个字典，
        # 用于存储每个字符串的排序后的字符串作为键，
        # 对应的字符串列表作为值
        # {'sorted string': ['anagram1', 'anagram2', ...]}
        anagram_dict = defaultdict(list)
        
        # 遍历输入的字符串列表
        for s in strs:
            # 对每个字符串进行排序
            sorted_s = ''.join(sorted(s))
            # 将排序后的字符串作为键，将原始字符串添加到对应的值列表中
            anagram_dict[sorted_s].append(s)

        # 返回字典中所有值列表的并集
        return list(anagram_dict.values())
```

### 6.4 确定两个字符串是否接近

**问题描述：**如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 **接近** ：

- 操作 1：交换任意两个 **现有** 字符。
  - 例如，`abcde -> aecdb`
- 操作 2：将一个 **现有** 字符的每次出现转换为另一个 **现有** 字符，并对另一个字符执行相同的操作。
  - 例如，`aacabb -> bbcbaa`（所有 `a` 转化为 `b` ，而所有的 `b` 转换为 `a` ）

你可以根据需要对任意一个字符串多次使用这两种操作。

给你两个字符串，`word1` 和 `word2` 。如果 `word1` 和 `word2` **接近** ，就返回 `true` ；否则，返回 `false` 。

**代码：**

```python
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        # 边界条件
        if len(word1) != len(word2):
            return False

        # 统计两个字符串中每个字符出现的次数
        freq1 = Counter(word1)
        freq2 = Counter(word2)

        # 条件 1：两个字符串必须包含相同的字符集合
        if set(freq1.keys()) != set(freq2.keys()):
            return False

        # 条件 2：两个字符串中每个字符出现的次数必须相同
        if sorted(freq1.values()) != sorted(freq2.values()):
            return False

        return True
```

## 七、排序 Sort

排序算法是计算机科学中最基本的问题之一，下表是常见排序算法的对比总结。

| **算法** |            平均时间复杂度            | 最坏时间复杂度 |  空间复杂度  | 稳定性 |        典型场景         |
| :------: | :----------------------------------: | :------------: | :----------: | :----: | :---------------------: |
| 冒泡排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    |  稳定  |   小规模/基本有序数据   |
| 选择排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    | 不稳定 | 小规模数据（简单实现）  |
| 插入排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    |  稳定  |   小规模/近似有序数据   |
| 快速排序 |             $O(n\log n)$             |    $O(n^2)$    | $O(n\log n)$ | 不稳定 |  通用场景（内存充足）   |
| 归并排序 |             $O(n\log n)$             |  $O(n\log n)$  |    $O(n)$    |  稳定  |    外排序/需要稳定性    |
|  堆排序  |             $O(n\log n)$             |  $O(n\log n)$  |    $O(1)$    | 不稳定 |      内存受限场景       |
| 希尔排序 |            $O(n^{1.25})$             |    $O(n^2)$    |    $O(1)$    | 不稳定 |      中等规模数据       |
| 计数排序 |               $O(n+k)$               |    $O(n+k)$    |   $O(n+k)$   |  稳定  |    数据范围小的整数     |
|  桶排序  | $O(n+ \frac{n}{k} \log \frac{n}{k})$ |    $O(n^2)$    |   $O(n+k)$   |  稳定  |   数据均匀分布的区间    |
| 基数排序 |             $O(d(n+k))$              |  $O(d(n+k))$   |   $O(n+k)$   |  稳定  | 多关键字/固定位数的数据 |

### 7.1 冒泡排序

**核心思想：**经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

```python
class Solution:
    def bubbleSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums

        # 冒泡排序
        for i in range(len(nums) - 1):
            # 第 i 趟冒泡
            is_swap = False
            for j in range(len(nums) - 1 - i):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    is_swap = True
            # 如果没有发生交换，说明已经有序，可以提前结束
            if not is_swap:
                break

        return nums
```

### 7.2 选择排序

**核心思想：**将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。

```python
class Solution:
    def selectSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        # 选择排序
        for i in range(len(nums) - 1):
            # 第 i 趟选择，记录未排序区间中最小值的位置
            min_idx = i
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[min_idx]:
                    min_idx = j
            # 如果找到最小值的位置
            if min_idx != i:
                # 将未排序区间最小值交换到已排序区间末尾
                nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
        return nums
```

### 7.3 插入排序

**核心思想：**将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。

```python
class Solultion:
    def insertSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        # 遍历无序区间，从第二个元素遍历
        for i in range(1, len(nums)):
            # 记录当前元素
            cur = nums[i]
            # 记录当前元素的前一个元素
            pre = i - 1
            # 如果当前元素小于前一个元素，则将前一个元素后移一位
            while pre >= 0 and cur < nums[pre]:
                nums[pre + 1] = nums[pre]
                pre -= 1
            # 将当前元素插入到合适的位置
            nums[pre + 1] = cur
            
        return nums
```

### 7.4 归并排序

**核心思想：**采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。

```python
class Solution:
    def mergeSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        def _merge(left_nums: List[int], right_nums: List[int]) -> List[int]:
            res = []
            i = j = 0
            
            # 比较两个数组的元素，将较小的元素加入结果
            while i < len(left_nums) and j < len(right_nums):
                if left_nums[i] <= right_nums[j]:
                    res.append(left_nums[i])
                    i += 1
                else:
                    res.append(right_nums[j])
                    j += 1

            # 将剩余的元素加入结果
            while i < len(left_nums):
                res.append(left_nums[i])
                i += 1
            while j < len(right_nums):
                res.append(right_nums[j])
                j += 1

            return res

        # 分治
        mid = len(nums) // 2
        left_nums = self.mergeSort(nums[:mid])
        right_nums = self.mergeSort(nums[mid:])

        # 合并
        return _merge(left_nums, right_nums)
```

### 7.5 快速排序

**核心思想：**采用经典的分治策略，选择数组中某个元素作为基准数，通过一趟排序将数组分为独立的两个子数组，一个子数组中所有元素值都比基准数小，另一个子数组中所有元素值都比基准数大。然后再按照同样的方式递归的对两个子数组分别进行快速排序，以达到整个数组有序。

```python
class Solution:
    def quickSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums

        def randomPartition(nums: List[int], low: int, high: int) -> int:
            """随机选择一个基准点，将数组分为两部分"""
            import random
            # 随机选择一个基准点
            random_index = random.randint(low, high)
            # 将基准点放到最右边
            nums[random_index], nums[high] = nums[high], nums[random_index]
            
            # 以最后一个元素为基准点（关键修正）
            pivot = nums[high]
            i = low - 1  # 小于基准的区域的边界
            
            # 遍历数组，将小于基准的元素移到左边
            for j in range(low, high):
                if nums[j] <= pivot:
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
            
            # 将基准元素放到正确位置
            nums[i + 1], nums[high] = nums[high], nums[i + 1]
            return i + 1
        
        def _qSort(nums: List[int], low: int, high: int) -> None:
            if low < high:
                # 随机选择一个基准点，将数组分为两部分，左边小于基准点，右边大于基准点
                pivot = randomPartition(nums, low, high)
                # 对左边部分进行排序
                _qSort(nums, low, pivot - 1)
                # 对右边部分进行排序
                _qSort(nums, pivot + 1, high)

        _qSort(nums, 0, len(nums) - 1)
        return nums

```

## 八、二分搜索



## 九、双指针

## 十、贪心

## 十一、回溯

## 十二、图搜索

## 十三、动态规划



