# 数据结构与算法面试宝典



## 一、栈 Stack

栈是一种后进先出 **(Last In First Out, LIFO)** 的数据结构，在 Python 中可以通过内置的 `list` 实现。

### 1.1 匹配字符串括号

**问题描述：**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 $s$ ，判断字符串是否有效。

**代码：**

```python
class Solution:
    def isValid(self, s: str) -> bool:
        # 边界条件，如果字符串为空或者长度为奇数，则返回 False
        if not s or len(s) % 2 != 0:
            return False
        
        # 初始化一个 stack
        stack = []
        # 定义一个字典，用于存储括号对
        bracket_dict = {')': '(', '}': '{', ']': '['}
        # 遍历字符串
        for char in s:
            # 如果是左括号，则入栈
            if char in "([{":
                stack.append(char)
            # 如果是右括号，则判断栈顶元素是否匹配
            else:
                # 如果不是空栈，且最后一个元素匹配，则出栈
                if stack and stack[-1] == bracket_dict[char]:
                    stack.pop()
                else:
                    return False
                
        # 如果栈为空，则说明所有括号都匹配
        return not stack
```

### 1.2 大鱼吃小鱼

**问题描述：**在水中有许多的鱼，可以认为这些鱼停放在 x 轴上。给定两个数组 $size$，$dir$，$size[i]$ 表示第 $i$ 条鱼的大小，$dir[i]$ 表示鱼的方向 (`0` 表示向左游，`1` 表示向右游)。这两个数组分别表示鱼的大小和游动的方向，并且这两个数组的长度相等。

这些鱼的行为都符合以下几个条件:

1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离
2. 当方向相对时，大鱼会吃掉小鱼
3. 鱼的大小都不一样

请计算还剩下几条鱼?

**代码：**

```python
class Solution:
    def fish(self, size: List[int], direction: List[int]) -> int:
        # 边界条件，如果只有一条鱼，则返回鱼的数量
        if len(size) <= 1:
            return len(size)

        # 初始化栈
        stack = []

        # 遍历每条鱼
        for i in range(len(size)):
            curr_size, curr_dir = size[i], direction[i]

            if curr_dir == 1:
                # 如果当前鱼向右游动，则直接入栈
                stack.append((curr_size, curr_dir))
            else:  # 向左游，可能与栈顶鱼相遇
                while stack and stack[-1][1] == 1:  # 栈顶鱼向右
                    if stack[-1][0] > curr_size:  # 栈顶鱼更大，当前鱼被吃
                        break
                    else:  # 当前鱼更大，吃掉栈顶鱼
                        stack.pop()
                else:  # 栈空或栈顶鱼向左，当前鱼存活
                    stack.append((curr_size, curr_dir))

        return len(stack)
```

### 1.3 单调栈问题

**问题描述：**给一个整数数组 $nums$，找到每个元素：右边第一个比自身小的下标位置，没有则用 `-1` 表示

**代码：**

```python
class Solution:
    def findRightSmall(self, nums: List[int]) -> List[int]:
        # 边界条件
        if not nums:
            return []
        
        # 初始化栈
        stack = []
        
        # 初始化结果
        res = [-1] * len(nums)

        # 遍历数组
        for i in range(len(nums)):
            # 如果栈不为空，且当前元素小于栈顶元素，则更新结果
            while stack and nums[i] < nums[stack[-1]]:
                res[stack.pop()] = i
            # 将当前元素下标入栈
            stack.append(i)

        return res
```

**解决单调栈问题的一般思路：**

|            **问题特征**             | **适用栈类型** |                **例子**                 |
| :---------------------------------: | :------------: | :-------------------------------------: |
|   找 **更大元素**（Next Greater）   |     递减栈     |     `[2,1,2,4,3]`→ `[4,2,4,-1,-1]`      |
|   找 **更小元素**（Next Smaller）   |     递增栈     |     `[2,1,2,4,3]`→ `[1,-1,-1,3,-1]`     |
| 找 **左侧更大元素**（Left Greater） |     递减栈     |     `[2,1,2,4,3]`→ `[-1,2,-1,-1,4]`     |
| 找 **左侧更小元素**（Left Smaller） |     递增栈     |     `[2,1,2,4,3]`→ `[-1,-1,1,2,2]`      |
|       计算 **直方图最大面积**       |     递增栈     |       `[2,1,5,6,2,3]`→ 面积 `10`        |
| 解决 **方向性问题**（如大鱼吃小鱼） | 递减栈（变种） | `Size=[4,2,5], Dir=[1,0,0]`→ 存活 `[5]` |

> - **递增栈**：用于找 **更小的元素** 或 **计算受较小元素限制的问题**（如直方图面积）。
> - **递减栈**：用于找 **更大的元素** 或 **计算受较大元素限制的问题**（如下一个更大元素）。
> - **方向性问题**：结合方向判断（如大鱼吃小鱼），通常用递减栈的变种。

## 二、队列 Queue

队列是一种先入先出**（First In First Out, FIFO）**的数据结构，在 Python 中可以通过内置的 `collections.deque` 实现。

### 2.1 二叉树的层序遍历

**问题描述：** 给定一个二叉树，返回其按层次遍历的节点值（即逐层从左到右遍历）。

**代码：**

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        # 边界条件
        if not root:
            return []

        # 初始化队列
        queue = deque([root])
        res = []

        while queue:
            # 当前层的节点数
            size = len(queue)
            # 存储当前层的节点值
            level = []
            for _ in range(size):
                # 弹出当前层的节点
                node = queue.popleft()
                # 将当前节点的值加入当前层的节点值列表
                level.append(node.val)
                
                # 将当前节点的左右子节点加入队列
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            # 将当前层的节点值列表加入结果列表
            res.append(level)
            
        return res
```

### 2.2 循环队列

**问题描述：**实现一个循环队列，支持以下操作：

- 入队：将一个元素添加到队列的末尾。
- 出队：从队列的头部移除一个元素。
- 获取队首元素：返回队列的头部元素。
- 获取队尾元素：返回队列的尾部元素。
- 判断队列是否为空：如果队列为空，返回 True；否则，返回 False。
- 判断队列是否已满：如果队列已满，返回 True；否则，返回 False。

**代码：**

```python
class MyCircularQueue:
    def __init__(self, size):
        self.size = size + 1
        self.queue = [None] * self.size
        self.front = 0
        self.rear = 0
        
    def is_empty(self):
        """判断队列是否为空"""
        return self.front == self.rear
    
    def is_full(self):
        """判断队列是否已满"""
        return (self.rear + 1) % self.size == self.front
    
    def enqueue(self, value):
        """入队操作"""
        if self.is_full():  
            raise Exception("Queue is full")
        else:
            self.rear = (self.rear + 1) % self.size
            self.queue[self.rear] = value

    def dequeue(self):
        """出队操作"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_front(self):
        """获取队首元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]

    def get_rear(self):
        """获取队尾元素"""
        if self.is_empty():
            raise Exception("Queue is empty")
        else:
            return self.queue[self.rear]
```

### 2.3 滑动窗口的最大值（单调队列）

**问题描述：**给定一个数组 $nums$ 和滑动窗口的大小 $k$，请找出所有滑动窗口里的最大值。

**代码：**

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if not nums or k <= 0:
            return []
        
        # 初始化双端队列（利用单调队列）
        dq = deque()
        res = []
        
        for i in range(len(nums)):
            # 移除超出窗口范围的元素
            while dq and dq[0] <= i - k:
                dq.popleft()
                
            # 维护递减队列
            while dq and nums[dq[-1]] < nums[i]:
                dq.pop()
                
            dq.append(i)
            
            # 记录当前窗口最大值
            if i >= k - 1:
                res.append(nums[dq[0]])
                
        return res
```

> **单调队列**是一种特殊的队列，其元素始终保持单调递增或递减的顺序。常用于维护滑动窗口的最值问题，能在 $O(1)$ 时间内获取当前窗口的最值。

## 三、优先队列 Priority Queue

优先队列通过堆来实现，堆是一种特殊的完全二叉树，分为大根堆和小根堆。

- **大根堆：**每个节点的值都大于或等于其子节点的值。
- **小根堆：**每个节点的值都小于或等于其子节点的值。

在 Python 中可以通过 `heapq` 来实现小根堆，如果需要实现大根堆可以通过取负的方法来达到大根堆的效果。

### 3.1 最小的 k 个数

**问题描述：** 给定一个数组 $nums$，找出其中最小的 $k$ 个数。

**代码：**

```python
class Solution:
    def getLeastNumbers(self, nums: List[int], k: int) -> List[int]:
        # 边界条件
        if k == 0:
            return []
        if not nums:
            return []
        if k >= len(nums):
            return nums

        # 使用堆排序
        max_heap = []
        for num in nums:
            if len(max_heap) < k:
                heapq.heappush(max_heap, -num)
            else:
                if -num > max_heap[0]:
                    heapq.heappop(max_heap)
                    heapq.heappush(max_heap, -num)
                    
        # 将堆中的负数转换回正数
        return [-num for num in max_heap]
```

### 3.2 跳跃游戏

**问题描述：**  假设你正在玩跳跃游戏，从低处往高处跳的时候，可以有两种方法：

- 方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。
- 方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的（一个只能用一次）。

其他无论是平着跳，还是从高处往低处跳，不需要借助什么就可以完成。

给你一个数组 $heights$，用来表示不同的高度。假设你总是站在 `index=0` 的高度开始。那么请问，你最远能跳到哪里？

**代码：**

```python
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, landers: int) -> int:
        # 边界条件
        if not heights:
            return -1
        
        # 初始化最大堆
        max_heap = []
        for i in range(len(heights) - 1):
            diff = heights[i + 1] - heights[i]
            if diff <= 0:
                continue
            
            # 使用梯子优先处理最大的高度差
            if landers > 0:
                heapq.heappush(max_heap, diff)
                landers -= 1
            else:
                # 如果没有梯子，尝试用砖块
                if max_heap and diff > max_heap[0]:
                    # 当前高度差比堆顶大，替换堆顶的高度差用砖块处理
                    smaller_ladder = heapq.heappop(max_heap)
                    if bricks >= smaller_ladder:
                        bricks -= smaller_ladder
                        heapq.heappush(max_heap, diff)
                        
                    else:
                        return i
                else:
                    # 当前高度差比堆顶小，或者堆为空，用砖块处理
                    if bricks >= diff:
                        bricks -= diff
                    else:
                        return i

        return len(heights) - 1
```

### 3.3 汽车加油次数

**问题描述：** 一辆汽车携带 $startFuel$ 升汽油从位置 `0` 出发前往位置 $target$，按顺序有一系列加油站 $stations$。

第 $i$ 个加油站位于 $stations[i][0]$，可以加 $stations[i][1]$ 升油（一个加油站只能加一次）。

如果想要到达 $target$，输出最少加油次数。如果不能到达 $target$，那么返回 `-1`。

同时满足两个条件：

1. 假设汽车油箱总是很大
2. 假设行走一单位距离，消耗一升汽油

**代码：**

```python
class Solution:
    def minRefuelStops(
        self, 
        target: int, 
        startFuel: int, 
        stations: List[List[int]]
    ) -> int:
        # 边界条件1：初始油量足够直接到达目标        
        if startFuel >= target:
            return 0
        
        # 边界条件2：没有加油站且初始油量不足
        if not stations:
            return -1
        
        # 初始化优先队列，存储油量
        max_heap = []
        curr_fuel = startFuel
        curr_pos = 0
        res = 0
        
        # 处理所有加油站
        for pos, fuel in stations + [[target, 0]]:
            # 边界条件3：忽略超过目标的加油站
            if pos > target:
                continue

            dist = pos - curr_pos
            # 油量不足以到达下一个位置时，从堆中取油
            while curr_fuel < dist:
                # 边界条件4：无油可加且无法到达
                if not max_heap:
                    return -1
                curr_fuel += -heapq.heappop(max_heap)
                res += 1

            # 将当前加油站油量加入堆中
            curr_fuel -= dist
            curr_pos = pos
            heapq.heappush(max_heap, -fuel)

        return res if curr_pos == target else -1
```

## 四、链表 Linked List

链表是一种线性数据结构，由一系列 **节点（Node）**组成，每个节点包含：

- **数据域**：存储数据（如整数、字符串等）。
- **指针域**：指向下一个节点的地址（或前一个节点，如果是双向链表）。

**解决链表问题的常用方法：** 

1. **双指针技巧：** 
   1. 快慢指针：判断环形链表、找中间节点、倒数第 k 个节点。
   2. 前后指针：反转链表、删除倒数第 N 个节点。
2. **递归法：** 反向操作（如反转链表）、分治问题（如合并有序链表）。
3. **虚拟头节点：** 简化边界处理（如删除链表中指定值的节点）

### 4.1 链表反转

**问题描述：** 给定单链表的头节点 `head`，反转链表，并返回反转后的链表的头节点。

**代码：**

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return head

        # 初始化指针
        prev, curr = None, head

        # 遍历链表
        while curr:
            # 保存当前节点的下一个节点
            next_node = curr.next
            # 将当前节点的 next 指针指向前一个节点
            curr.next = prev 
            # 将前一个节点移动到当前节点
            prev = curr
            # 将当前节点移动到下一个节点
            curr = next_node

        # 返回反转后的链表头节点
        return prev
```

### 4.2 删除链表中指定值的节点

**问题描述：**给定单向链表的头指针 $head$ 和一个要删除的节点的值 $val$，定义一个函数删除该节点。返回删除后的链表的头节点。

**代码：**

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head

        # 创建哑节点
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        
        # 遍历链表
        while curr.next:
            # 如果当前节点的下一个节点的值等于 val
            if curr.next.val == val:
                # 删除下一个节点
                curr.next = curr.next.next
            else:
                curr = curr.next

        return dummy.next
```

### 4.3 链表的倒数第 k 个节点

**问题描述：** 给定一个链表，删除链表中的倒数第 $k$ 个节点。

**代码：**

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 边界条件
        if not head:
            return head
        
        # 创建一个 dummy
        dummy = ListNode(0)
        dummy.next = head
        
        # 快慢指针
        slow = fast = dummy
        
        # 快指针先走 k 步
        for _ in range(k + 1):
            fast = fast.next

        # 快慢指针同时走，直到快指针到达链表末尾
        while fast.next:
            slow = slow.next
            fast = fast.next

        # 删除倒数第 k 个节点
        slow.next = slow.next.next

        return head
```

### 4.4 链表环问题

**问题描述：** 给你一个链表的头节点 $head$ ，判断链表中是否有环。如果有环，请找出环的入口节点。

**代码：**

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界条件
        if not head or not head.next:
            return None
        
        # 快慢指针
        slow = fast = head
        # 记录是否存在环
        has_cycle = False

        # 使用快慢指针法判断是否存在环
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        # 如果不存在环，则返回
        if not has_cycle:
            return None
        
        # 如果存在环，则找到环的入口节点
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

## 五、二叉树 Binary Tree

**二叉树**是一种重要的数据结构，每个节点最多有两个子节点（左子节点和右子节点）。二叉树存在一些基本概念：

- **节点（Node）**：存储数据的基本单位，包含：
  - **数据域（val）**：存储值。
  - **左指针（left）**：指向左子节点。
  - **右指针（right）**：指向右子节点。
- **根节点（Root）**：树的起点，没有父节点。
- **叶子节点（Leaf）**：没有子节点的节点。
- **深度（Depth）**：从根到该节点的最长路径的边数。
- **高度（Height）**：从该节点到最深叶子节点的最长路径的边数（通常根的高度最大）。
- **度（Degree）**：节点的子节点数（二叉树中最大为2）。

### 5.1 二叉树的遍历

二叉树遍历是指按照某种顺序访问树的所有节点，主要分为 **深度优先遍历（DFS）** 和 **广度优先遍历（BFS）**。每种遍历方式有不同的应用场景。

| 遍历方式 |   顺序   | 递归 | 迭代（栈/队列） |      应用场景      |
| :------: | :------: | :--: | :-------------: | :----------------: |
| **前序** | 根→左→右 |  ✅   |     ✅（栈）     |   复制树、序列化   |
| **中序** | 左→根→右 |  ✅   |     ✅（栈）     |    BST 有序输出    |
| **后序** | 左→右→根 |  ✅   |  ✅（栈+反转）   | 删除树、表达式求值 |
| **层序** | 按层遍历 |  ❌   |    ✅（队列）    |  求高度、最短路径  |

**代码：** 层序遍历的实现在 [2.1 二叉树的层序遍历](###2.1 二叉树的层序遍历) 中展示过

```python
class Solution:
    def preOrder(self, root: Optional[TreeNode]) -> List[int]:
        """前序遍历"""
        # 边界条件
        if not root:
            return []
        
        # 递归
        return [root.val] + self.preOrder(root.left) + self.preOrder(root.right)

    def inOrder(self, root: Optional[TreeNode]) -> List[int]:
        """中序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.inOrder(root.left) + [root.val] + self.inOrder(root.right)

    def postOrder(self, root: Optional[TreeNode]) -> List[int]:
        """后序遍历"""
        # 边界条件
        if not root:
            return []

        # 递归
        return self.postOrder(root.left) + self.postOrder(root.right) + [root.val]
```

### 5.2 验证二叉搜索树

**问题描述：** 给定一个二叉树，判断其是否是一个有效的二叉搜索树。

**代码：**

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(node, lower=float('-inf'), upper=float('inf')):
            """通过递归判断二叉树是否是二叉搜索树"""
            if not node:
                return True

            # 如果当前节点的值不在合法范围内，则不是二叉搜索树
            val = node.val
            if val <= lower or val >= upper:
                return False

            # 递归判断左子树和右子树
            # 左子树的值一定要小于当前节点的值，
            # 右子树的值一定要大于当前节点的值
            return dfs(node.left, lower, val) and dfs(node.right, val, upper)

        return dfs(root)
```

> **二叉搜索树（Binary Search Tree, BST）**是一种特殊的二叉树，具有高效的查找、插入和删除特性，广泛应用于数据库索引、内存查找等场景。
>
> **BST 性质**：BST 的中序遍历总是生成严格升序序列。
>
> - 左子树所有节点的值 **<** 根节点的值。
> - 右子树所有节点的值 **>** 根节点的值。
> - 左右子树也必须是 BST（递归定义）。

### 5.3 目标和的所有路径

**问题描述：**给定一颗二叉树，一个目标值 $target$。请输出所有路径，需要满足根节点至叶子节点之和等于给定的目标值

**代码：**

```python
class Solution:
    def findTargetSumWays(self, root: Optional[TreeNode], target: int) -> List[List[int]]:
        # 边界条件
        if not root:
            return []
        
        # 用于存储结果
        res = []
        
        def backtrace(
            node: Optional[TreeNode], 
            path: List[int], current_sum: int, target: int
        ):
            """回溯算法"""
            # 终止条件
            if not node:
                return
            
             # 更新当前路径和
            current_sum += node.val
            path.append(node.val)

            # 检查是否是叶子节点且满足条件
            if not node.left and not node.right and current_sum == target:
                res.append(path[:])
            
            # 递归遍历左右子树
            backtrace(node.left, path, current_sum, target)
            backtrace(node.right, path, current_sum, target)
            
            # 回溯
            path.pop()

        backtrace(root, [], 0, target)
        return res
```

### 5.4 删除二叉搜索树的节点

**问题描述：** 删除二叉搜索树的指定节点。返回删除之后的根节点。

**代码：**

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # 边界条件
        if not root:
            return None
        # 如果这个值比根节点小，则从左子树删除
        if val < root.val:
            root.left = self.deleteNode(root.left, val)
        # 如果这个值比根节点大，则从右子树删除
        elif val > root.val:
            root.right = self.deleteNode(root.right, val)
        else:
            # 找到要删除的节点
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                # 左右子树都不为空，找到右子树的最小节点
                successor = root.right
                while successor.left:
                    successor = successor.left
                # 用后继节点的值替换当前节点
                root.val = successor.val
                # 删除后继节点
                root.right = self.deleteNode(root.right, successor.val)
        
        return root
```

## 六、哈希表 Hash Table

哈希表（又称散列表）是一种**基于键值对（Key-Value）存储的高效数据结构**，其核心思想是通过**哈希函数（Hash Function）**将任意类型的键（Key）映射到一个固定范围的整数索引（桶，Bucket），并将值（Value）存储在该索引对应的存储位置中。在 Python 中可以通过内置的 `dict` 类型实现。

> 哈希表的运行依赖三个核心组件：
>
> 1. **哈希函数（Hash Function）**
> 2. **存储数组（Bucket Array）**
> 3. **冲突解决机制（Collision Resolution）**

```python
class HashTable:
    def __init__(self, capacity: int, load_factor: float = .75):
        """初始化哈希表"""
        self.capacity = capacity # 底层数组的大小
        self.load_factor = load_factor # 负载因子阈值
        self.size = 0 # 哈希表中元素的数量
        self.buckets = [[] for _ in range(self.capacity)] # 底层数组，每个元素是一个链表

    def _hash(self, key) -> int:
        """哈希函数，将键值映射到索引"""
        return hash(key) % self.capacity
    
    def put(self, key, value) -> None:
        """插入键值对"""
        # 1. 计算桶的索引
        index = self._hash(key)
        bucket = self.buckets[index]

        # 2. 检查键是否已经存在
        for i, (k, v) in enumerate(bucket):
            if k == key:
                # 3. 如果键已经存在，更新值
                bucket[i] = (key, value)
                return

        # 4. 如果键不存在，添加新的键值对
        bucket.append((key, value))
        self.size += 1
        
        # 5. 检查负载因子，如果超过阈值，则扩容
        if self.size / self.capacity > self.load_factor:
            self._resize()
    
    def get(self, key):
        """获取键对应的值"""
        index = self._hash(key)
        bucket = self.buckets[index]

        for k, v in bucket:
            if k == key:
                return v

        # 未找到键
        raise KeyError(f"Key '{key}' not found")
    
    def _resize(self) -> None:
        """扩容哈希表"""
        old_buckets = self.buckets  # 保存旧桶数据
        self.capacity *= 2
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]

        # 将旧桶中的所有键值对重新插入新桶
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)  
                # 复用 put 方法（自动处理哈希和冲突）
```

### 6.1 哈希冲突的解决方法

哈希冲突（Hash Collision）是指**不同的键（Key）通过哈希函数计算后，得到相同的哈希值（索引）**，导致它们被映射到哈希表的同一个桶（Bucket）中。冲突会破坏哈希表的 *O*(1)时间复杂度特性，因此必须通过合理的冲突处理机制来解决。

根据处理思路的不同，冲突处理可分为**开放寻址法**和**链地址法**两大类，此外还有一些变种或优化方法。

1. **开放寻址法（Open Addressing）：** **所有键值对直接存储在桶数组中**，当冲突发生时，通过某种“探测规则”寻找下一个可用的空桶，将冲突的键值对存储在该位置。
   1. **线性探测：**冲突时，从当前桶的下一个位置开始，依次探测后续的桶（索引递增，到数组末尾后循环到开头），直到找到一个空桶。
   2. **二次探测：**冲突时，探测序列为当前索引的二次方偏移。
   3. **双重哈希：**使用两个独立的哈希函数。冲突时，通过第二个哈希函数计算探测步长。
2. **链地址法（Separate Chaining）：** **每个桶存储一个链表（或其他动态数据结构），冲突的键值对被添加到同一桶的链表中**。查找时，先通过哈希函数定位桶，再遍历链表查找目标键。
   1. **链表存储：**每个桶是一个链表（或动态数组），冲突的键值对按顺序添加到链表中。
   2. **链表转树：**当链表长度超过阈值，将链表转换为红黑树（平衡二叉搜索树），将查找时间优化到 $O(\log n)$。

### 6.2 两数之和

**问题描述：** 给定一个整数数组 $nums$ 和一个整数目标值 $target$，请你在该数组中找出 **和为目标值** $target$ 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**代码：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # {'num': 'index'}
        mapping = defaultdict(int)

        # 遍历数组
        for i, num in enumerate(nums):
            # 计算差值
            diff = target - num
            # 如果差值在字典中，则返回差值的索引和当前索引
            if diff in mapping:
                return [mapping[diff], i]
            # 如果差值不在字典中，则将当前数字和索引存入字典
            mapping[num] = i
            
        return []
```

### 6.3 字母异位词分组

**问题描述：**给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**代码：**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # 初始化一个字典，
        # 用于存储每个字符串的排序后的字符串作为键，
        # 对应的字符串列表作为值
        # {'sorted string': ['anagram1', 'anagram2', ...]}
        anagram_dict = defaultdict(list)
        
        # 遍历输入的字符串列表
        for s in strs:
            # 对每个字符串进行排序
            sorted_s = ''.join(sorted(s))
            # 将排序后的字符串作为键，将原始字符串添加到对应的值列表中
            anagram_dict[sorted_s].append(s)

        # 返回字典中所有值列表的并集
        return list(anagram_dict.values())
```

### 6.4 确定两个字符串是否接近

**问题描述：**如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 **接近** ：

- 操作 1：交换任意两个 **现有** 字符。
  - 例如，`abcde -> aecdb`
- 操作 2：将一个 **现有** 字符的每次出现转换为另一个 **现有** 字符，并对另一个字符执行相同的操作。
  - 例如，`aacabb -> bbcbaa`（所有 `a` 转化为 `b` ，而所有的 `b` 转换为 `a` ）

你可以根据需要对任意一个字符串多次使用这两种操作。

给你两个字符串，$word_1 $ 和 $word_2$ 。如果 $word_1 $ 和 $word_2 $ **接近** ，就返回 `true` ；否则，返回 `false` 。

**代码：**

```python
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        # 边界条件
        if len(word1) != len(word2):
            return False

        # 统计两个字符串中每个字符出现的次数
        freq1 = Counter(word1)
        freq2 = Counter(word2)

        # 条件 1：两个字符串必须包含相同的字符集合
        if set(freq1.keys()) != set(freq2.keys()):
            return False

        # 条件 2：两个字符串中每个字符出现的次数必须相同
        if sorted(freq1.values()) != sorted(freq2.values()):
            return False

        return True
```

## 七、排序算法 Sort Algorithm

排序算法是计算机科学中最基本的问题之一，下表是常见排序算法的对比总结。

| **算法** |            平均时间复杂度            | 最坏时间复杂度 |  空间复杂度  | 稳定性 |        典型场景         |
| :------: | :----------------------------------: | :------------: | :----------: | :----: | :---------------------: |
| 冒泡排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    |  稳定  |   小规模/基本有序数据   |
| 选择排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    | 不稳定 | 小规模数据（简单实现）  |
| 插入排序 |               $O(n^2)$               |    $O(n^2)$    |    $O(1)$    |  稳定  |   小规模/近似有序数据   |
| 快速排序 |             $O(n\log n)$             |    $O(n^2)$    | $O(n\log n)$ | 不稳定 |  通用场景（内存充足）   |
| 归并排序 |             $O(n\log n)$             |  $O(n\log n)$  |    $O(n)$    |  稳定  |    外排序/需要稳定性    |
|  堆排序  |             $O(n\log n)$             |  $O(n\log n)$  |    $O(1)$    | 不稳定 |      内存受限场景       |
| 希尔排序 |            $O(n^{1.25})$             |    $O(n^2)$    |    $O(1)$    | 不稳定 |      中等规模数据       |
| 计数排序 |               $O(n+k)$               |    $O(n+k)$    |   $O(n+k)$   |  稳定  |    数据范围小的整数     |
|  桶排序  | $O(n+ \frac{n}{k} \log \frac{n}{k})$ |    $O(n^2)$    |   $O(n+k)$   |  稳定  |   数据均匀分布的区间    |
| 基数排序 |             $O(d(n+k))$              |  $O(d(n+k))$   |   $O(n+k)$   |  稳定  | 多关键字/固定位数的数据 |

### 7.1 冒泡排序

**核心思想：**经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

```python
class Solution:
    def bubbleSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums

        # 冒泡排序
        for i in range(len(nums) - 1):
            # 第 i 趟冒泡
            is_swap = False
            for j in range(len(nums) - 1 - i):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    is_swap = True
            # 如果没有发生交换，说明已经有序，可以提前结束
            if not is_swap:
                break

        return nums
```

### 7.2 选择排序

**核心思想：**将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。

```python
class Solution:
    def selectSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        # 选择排序
        for i in range(len(nums) - 1):
            # 第 i 趟选择，记录未排序区间中最小值的位置
            min_idx = i
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[min_idx]:
                    min_idx = j
            # 如果找到最小值的位置
            if min_idx != i:
                # 将未排序区间最小值交换到已排序区间末尾
                nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
        return nums
```

### 7.3 插入排序

**核心思想：**将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。

```python
class Solultion:
    def insertSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        # 遍历无序区间，从第二个元素遍历
        for i in range(1, len(nums)):
            # 记录当前元素
            cur = nums[i]
            # 记录当前元素的前一个元素
            pre = i - 1
            # 如果当前元素小于前一个元素，则将前一个元素后移一位
            while pre >= 0 and cur < nums[pre]:
                nums[pre + 1] = nums[pre]
                pre -= 1
            # 将当前元素插入到合适的位置
            nums[pre + 1] = cur
            
        return nums
```

### 7.4 归并排序

**核心思想：**采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。

```python
class Solution:
    def mergeSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums
        
        def _merge(left_nums: List[int], right_nums: List[int]) -> List[int]:
            res = []
            i = j = 0
            
            # 比较两个数组的元素，将较小的元素加入结果
            while i < len(left_nums) and j < len(right_nums):
                if left_nums[i] <= right_nums[j]:
                    res.append(left_nums[i])
                    i += 1
                else:
                    res.append(right_nums[j])
                    j += 1

            # 将剩余的元素加入结果
            while i < len(left_nums):
                res.append(left_nums[i])
                i += 1
            while j < len(right_nums):
                res.append(right_nums[j])
                j += 1

            return res

        # 分治
        mid = len(nums) // 2
        left_nums = self.mergeSort(nums[:mid])
        right_nums = self.mergeSort(nums[mid:])

        # 合并
        return _merge(left_nums, right_nums)
```

### 7.5 快速排序

**核心思想：**采用经典的分治策略，选择数组中某个元素作为基准数，通过一趟排序将数组分为独立的两个子数组，一个子数组中所有元素值都比基准数小，另一个子数组中所有元素值都比基准数大。然后再按照同样的方式递归的对两个子数组分别进行快速排序，以达到整个数组有序。

```python
class Solution:
    def quickSort(self, nums: List[int]) -> List[int]:
        # 边界条件
        if len(nums) <= 1:
            return nums

        def randomPartition(nums: List[int], low: int, high: int) -> int:
            """随机选择一个基准点，将数组分为两部分"""
            import random
            # 随机选择一个基准点
            random_index = random.randint(low, high)
            # 将基准点放到最右边
            nums[random_index], nums[high] = nums[high], nums[random_index]
            
            # 以最后一个元素为基准点（关键修正）
            pivot = nums[high]
            i = low - 1  # 小于基准的区域的边界
            
            # 遍历数组，将小于基准的元素移到左边
            for j in range(low, high):
                if nums[j] <= pivot:
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
            
            # 将基准元素放到正确位置
            nums[i + 1], nums[high] = nums[high], nums[i + 1]
            return i + 1
        
        def _qSort(nums: List[int], low: int, high: int) -> None:
            if low < high:
                # 随机选择一个基准点，将数组分为两部分，左边小于基准点，右边大于基准点
                pivot = randomPartition(nums, low, high)
                # 对左边部分进行排序
                _qSort(nums, low, pivot - 1)
                # 对右边部分进行排序
                _qSort(nums, pivot + 1, high)

        _qSort(nums, 0, len(nums) - 1)
        return nums

```

## 八、二分搜索 Binary Search

二分搜索是一种在 **有序数组（或有序容器）** 中高效查找目标值的算法，其核心思想是：**每次将搜索范围缩小一半，通过比较中间元素与目标值，决定接下来搜索左半部分还是右半部分。**

> 二分搜索实现的前提条件是数组必须是 **有序的**。

| 特性             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| **时间复杂度**   | $O(\log n)$：每次将搜索范围缩小一半，最多需要 $O(\log n)$ 次比较。 |
| **空间复杂度**   | $O(1)$：只用了常数个额外变量（如指针），是原地算法。         |
| **适用数据结构** | **有序数组 / 有序列表**（必须是已经排好序的！）。            |
| **常见变种问题** | 查找第一个/最后一个等于目标的元素、查找插入位置、查找最接近的值等。 |

### 8.1 有序数组中最左边的元素

**问题描述：** 给定一个有序数组 $nums$，返回指定元素 $target$ 的最左边的位置

**代码：**

```python
class Solution:
    def findLeftMost(self, nums: List[int], target: int) -> int:
        # 边界条件
        if not nums:
            return -1
        
        left, right = 0, len(nums) - 1
        result = -1  # 用于记录最左边的索引
        
        # 二分搜索
        while left <= right:
            mid = left + (right - left) // 2 # 避免整数溢出
            if nums[mid] == target:
                result = mid # 记录当前位置
                right = mid - 1 # 继续往左搜索
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return result
```

### 8.2 寻找山峰

**问题描述：**数组里的元素组成一个山峰，位于峰顶的元素，总是比它左边和右边的元素大。请找出这个峰顶元素。

**代码：**

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        # 边界条件
        if not nums:
            return -1
        
        left, right = 0, len(nums) - 1
        
        # 二分搜索
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < nums[mid + 1]:
                left = mid + 1 # 峰顶在右侧
            else:
                right = mid # 峰顶在左侧或 mid 就是峰顶

        return left 
```

### 8.3 最大平均值

**问题描述：**给定一个正整数数组 $nums$ 和 $k$，要求找到子数组，输出其最大平均值。并且子数组长度要满足大于等于 $k$。

**代码：**

```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        # 边界条件：如果数组为空，返回0
        if not nums:
            return 0
        
        def _check(num) -> bool:
            """
            检查是否存在长度为k的子数组，其平均值大于等于num
            通过计算前缀和来判断
            """
            # 构建前缀和数组，每个元素减去num
            prefix = [0] * (len(nums) + 1)
            for i in range(len(nums)):
                prefix[i + 1] = prefix[i] + nums[i] - num
            
            # 维护最小前缀和
            min_prefix = 0
            # 检查是否存在长度为k的子数组满足条件
            for i in range(k, len(nums) + 1):
                if prefix[i] - min_prefix >= 0:
                    return True
                min_prefix = min(min_prefix, prefix[i - k + 1])
            return False
        
        # 初始化二分查找的左右边界为数组的最小值和最大值
        left, right = min(nums), max(nums)
        # 使用二分查找寻找最大平均值
        while left < right:
            mid = (left + right) / 2
            if _check(mid):
                left = mid
            else:
                right = mid
                
        return left
```

## 九、双指针 Two Pointers

双指针是一种高效的算法设计技巧，通过使用**两个指针（索引）在数组、链表或其他数据结构上协同移动**，来优化时间复杂度或简化逻辑。其核心思想是：**“通过两个指针的相对移动（同向或反向），高效解决涉及遍历、搜索、比较或滑动窗口的问题。”**

| **场景**                | **双指针类型** | **示例问题**                           |
| ----------------------- | -------------- | -------------------------------------- |
| **数组/链表遍历优化**   | 同向           | 删除排序数组中的重复项、链表中环的检测 |
| **有序数组搜索**        | 反向           | 两数之和、反转字符串                   |
| **子数组/子字符串问题** | 滑动窗口       | 最长无重复字符子串、最小覆盖子串       |
| **数学问题**            | 反向           | 盛最多水的容器、接雨水问题             |

### 9.1 不含重复字符的最长区间

**问题描述：**给定一个字符串 $s$，找到它的最长无重复字符的子串的长度。

**代码：**

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 边界条件
        if not s:
            return 0
        if len(s) == 1:
            return 1
        
        # 初始化
        left, max_len = 0, 0
        char_index = {}  # 记录字符的最后出现位置
        
        for right in range(len(s)):
            if s[right] in char_index and char_index[s[right]] >= left:
                # 直接跳到重复字符的下一个位置
                left = char_index[s[right]] + 1
            char_index[s[right]] = right # 更新字符位置
            max_len = max(max_len, right - left + 1) # 更新最大长度

        return max_len
```

### 9.2 区间计数

**问题描述：**给定一个正数数组 $nums$，以及一个正整数 $k$，求乘积小于 $k$ 的子数组的个数。

**代码：**

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # 边界条件
        if not nums:
            return 0
        if k <= 1:
            return 0
        
        # 初始化
        left, product, count = 0, 1, 0
        
        for right in range(len(nums)):
            product *= nums[right]
            # 如果乘积大于等于 k，则移动左边界
            while product >= k:
                product /= nums[left]
                left += 1
            # 统计以 right 结尾的子数组数量
            count += right - left + 1

        return count
```

### 9.3 定长子串

**问题描述：**给定两个字符串 $s_1$ 和 $s_2$，判断 $s_2$ 字符串是否包含 $s_1$ 字符串的任意排列

**代码：**

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        # 边界条件：如果 s1 为空，返回 True
        if not s1:
            return True
        # 边界条件：如果 s2 为空，返回 False
        if not s2:
            return False
        
        need = Counter(s1) # s1 的字符频率
        window = defaultdict(int) # 窗口内的字符频率
        left, valid = 0, 0 # 窗口左边界和匹配的字符数

        for right in range(len(s2)):
            c = s2[right]
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
            # 窗口长度 >= s1 的长度时，开始收缩窗口
            while (right - left + 1) >= len(s1):
                # 如果窗口内的字符频率与 s1 的字符频率完全匹配，返回 True
                if valid == len(need):
                    return True
                # 窗口左边界字符
                d = s2[left]
                # 如果该字符是 s1 需要的字符
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1 # 如果之前是完美匹配，现在不再匹配
                    window[d] -= 1 # 从窗口频率中移除该字符
                left += 1
        return False
```

>**用滑动窗口维护 $s_2$ 的子串频率，当与 $s_1$ 的频率完全匹配时，说明存在排列。**

### 9.4 最短子串

**问题描述：**给定两个字符串 $s_1$ 和 $s_2$，给出 $s_1$ 字符串中的最短子串，要能够包含 $s_2$ 字符串中的所有字符。

**代码：**

```python
class Solution:
    def minWindow(self, s1: str, s2: str) -> str:
        # 边界条件
        if not s1 or not s2:
            return ""

        
        need = Counter(s2) # s2 的字符频率
        window = defaultdict(int) # 窗口中的字符频率

        left, valid = 0, 0 # 窗口左边界和匹配的字符数
        min_len = float('inf') # 最短字符串的长度
        start = 0 # 最短字符串的起始位置

        for right in range(len(s1)):
            # 右边界字符加入窗口
            c = s1[right]
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1

            # 当窗口覆盖 s2 时，尝试收缩左边界
            while valid == len(need):
                # 更新最短子串
                if right - left + 1 < min_len:
                    min_len = right - left + 1
                    start = left

                # 左边界字符移出窗口
                d = s1[left]
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
                left += 1

        return "" if min_len == float('inf') else s1[start: start + min_len]

```

## 十、贪心算法 Greedy Algorithm

贪心算法是一种通过**每一步选择当前状态下的局部最优解**，最终期望达到全局最优解的算法设计策略。其核心思想是“短视”地选择当前最有利的选项，不回溯或重新考虑之前的选择。

>1. **贪心选择性质（Greedy Choice Property）**
>   - 问题的全局最优解可以通过一系列局部最优选择（贪心选择）得到。
>   - 每一步的局部最优选择必须能引导后续选择走向全局最优。若此性质不成立，贪心算法无法得到正确结果。
>
>2. **最优子结构（Optimal Substructure）**
>   - 问题的最优解包含其子问题的最优解。
>   - 贪心算法通常依赖最优子结构，通过解决子问题的最优解逐步构建全局最优解。

当你看到以下关键词时，要警惕贪心可能不适用：

| 关键词      | 不能使用贪心的原因 | 可替代方法 |
| :---------- | :----------------- | :--------- |
| "最多k次"   | 有限制的多阶段决策 | 动态规划   |
| "恰好k次"   | 精确约束           | 动态规划   |
| "手续费"    | 额外成本影响决策   | 动态规划   |
| "冷却期"    | 状态转移受限       | 动态规划   |
| "所有方案"  | 需要完整搜索       | 回溯/DFS   |
| "至少/至多" | 约束条件复杂       | 动态规划   |
| "同时持有"  | 状态复杂           | 动态规划   |

### 10.1 木桶装水

**问题描述：**给定一个数组 $heights$，表示不同的木板的高度，在装水的时候，你可以选择两根木板，然后装满水，在不能倾斜的情况下，里面能装多少水，应该由较短的木板决定。请问最多能装多少水？

**代码：**

```python
class Solution:
    def maxArea(self, heights: List[int]) -> int:
        # 边界条件
        if len(heights) < 2:
            return 0
        
        # 初始化左右指针
        left, right = 0, len(heights) - 1
        max_area = 0
        
        while left < right:
            # 计算当前面积
            curr_area = min(heights[left], heights[right]) * (right - left)
            max_area = max(max_area, curr_area)

            # 移动较短的木板
            if heights[left] < heights[right]:
                left += 1
            else:
                right -= 1

        return max_area
```

### 10.2 不重叠区间

**问题描述：**给定一系列区间 $intervals$，请你选一个子集，使得这个子集中的区间都不相互重叠，并且这个子集里面的元素个数最多。

**代码：**

```python
class Solution:
    def maxNonOverlapping(self, intervals: List[List[int]]) -> int:
        # 边界条件
        if not intervals:
            return 0
        
        # 按结束时间升序排序
        intervals.sort(key=lambda x: x[1])
        
        # 初始化结果和第一个区间的结束时间
        res = 1
        last_end = intervals[0][1]

        # 遍历区间
        for start, end in intervals[1:]:
            # 如果当前区间的开始时间大于等于上一个区间的结束时间，则不重叠
            if start >= last_end:
                res += 1
                last_end = end

        return res
```

### 10.3 青蛙跳

**问题描述：**给定一个数组 $nums$，元素 $nums[i] \ge 0$，一只青蛙站在 $index=i$，那它可以跳到 $nums[i+1],...,nums[i+nums[i]]$ （不能跳出数组）。请问这只青蛙从 $index=0$ 出发，能不能跳到 $index=nums.length-1$

**代码：**

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 边界条件
        if len(nums) == 1:
            return True
        if nums[0] == 0:
            return False

        # 初始化
        max_reach = 0 # 当前能跳到的最远距离
        
        for i in range(len(nums)):
            # 如果当前能跳到的最远距离小于当前下标，说明无法跳到终点
            if i > max_reach:
                return False
            # 更新能跳到的最远距离
            max_reach = max(max_reach, i + nums[i])
            # 如果能跳到的最远距离大于等于终点下标，说明可以跳到终点
            if max_reach >= len(nums) - 1:
                return True

        return False
```

### 10.4 加油站

**问题描述：**巨大的环形赛道上有 $N$ 个加油站，第 $i$ 个加油站可以加油 $gas[i]$ 升，而从第 $i$ 个加油站开到下一个加油站，需要 **消耗** $costs[i]$ 升汽油。请你选择一个起始加油站，能够跑完环形赛道一圈。条件：

1. 环形赛道；2. 汽车油箱总是足够大

**代码：**

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], costs: List[int]) -> int:
        # 边界条件
        if not gas or not costs:
            return -1
        # 如果总油量小于总消耗量，则无法跑完一圈
        if sum(gas) < sum(costs):
            return -1
        
        # 初始化
        start = 0
        curr_gas = 0
        
        for i in range(len(gas)):
            # 当前油量
            curr_gas += gas[i] - costs[i]
            # 如果当前油量小于0，则从下一个加油站重新开始
            if curr_gas < 0:
                start = i + 1
                curr_gas = 0

        return start if start < len(gas) else -1
```

## 十一、回溯算法 Backtrack Algorithm

回溯算法是一种通过**深度优先搜索（DFS）**遍历所有可能解空间的算法思想。其核心是通过“尝试-验证-回退”的循环，在每一步选择中探索可能的路径，若当前路径无法满足约束条件（或已到达终点），则回溯到上一步，尝试其他选择，直到找到所有符合条件的解或遍历完所有可能。

> **回溯算法是“穷举所有可能，但通过剪枝剔除无效路径”的高效枚举方法。**

以通用回溯框架为例，步骤如下：

1. 定义状态变量：
   - `path`：当前已选择的路径（如已选的数字、已放置的皇后位置）
   - `used`：标记已使用的元素（避免重复选择，如排列问题中的去重）
   - 其他辅助函数（如当前步数、剩余目标值等）
2. 设计递归函数 `backtrack`
3. 剪枝优化，在遍历 **可选选择列表** 时，提前过滤掉不满足约束条件的选择

```python
def backtrack(参数):
    if 终止条件（找到解/无法继续）:
        记录解并返回
    for 选择 in 当前可选的选择列表:
        if 剪枝条件（当前选择不合法）:
            continue  # 跳过无效选择
        选择当前元素（更新path/used等状态）
        backtrack(下一层参数)  # 递归探索下一层
        撤销当前选择（回溯，恢复path/used等状态）  # 关键！
```

### 11.1 电话号码的字母组合

**问题描述：**给定一个手机拨号盘，不同的按键对应不同的字母。现在给定数字字符串的输入，请你返回所有可能的小写字母组合。输入的数字只会有 2~9。

**代码：**

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        # 边界条件
        if not digits:
            return []
        
        # 初始化映射
        digit_mapping = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }

        # 初始化结果
        res = []

        # 回溯
        def backtrack(start: int, curr_str: list):
            # 循环终止条件
            if start == len(digits):
                res.append("".join(curr_str))
                return
            
            # 循环遍历
            curr_digits = digits[start]
            for char in digit_mapping[curr_digits]:
                # 选择
                curr_str.append(char)
                # 递归
                backtrack(start + 1, curr_str)
                # 撤销选择 
                curr_str.pop()
        
        backtrack(0, [])
        return res
```

### 11.2 子集

**问题描述：**给定一个数组 $nums$，其中元素互不相同，返回这个数组里面所有的可能的子集（包括空集）。要求子集不能重复。

**代码：**

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # 边界条件
        if not nums:
            return [[]]
        
        # 初始化结果
        res = []

        # 回溯
        def backtrack(start: int, curr_set: List[int]):  
            # 将当前子集添加到结果中
            # curr_set[:] 是 curr_set 的一个拷贝，
            # 因为 curr_set 是一个可变对象，如果不拷贝，
            # curr_set 中的元素会被清空
            res.append(curr_set[:])  
            
            # 遍历数组，从 start 开始
            for i in range(start, len(nums)):
                # 将当前元素添加到当前子集中
                curr_set.append(nums[i])
                # 递归调用 backtrack，从下一个元素开始
                backtrack(i + 1, curr_set)
                # 回溯，将当前元素从当前子集中移除
                curr_set.pop()

        backtrack(0, [])
        return res
```

### 11.3 排列

**问题描述：**给定无重复元素的数组 $nums$，输出这个数组所有的排列。

**代码：**

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        # 边界条件
        if len(nums) <= 1:
            return [nums]
        
        # 初始化结果
        res = []

        # 回溯
        def backtrack(curr_list: List[int]):
            # 循环终止条件：如果当前排列长度等于原来数组的长度
            if len(curr_list) == len(nums):
                res.append(curr_list[:])
                return
            
            for num in nums:
                # 剪枝：如果当前元素已经在当前排列中，则跳过
                if num in curr_list:
                    continue
                
                # 做选择
                curr_list.append(num)
                # 递归
                backtrack(curr_list)
                # 撤销选择
                curr_list.pop()              
                
        backtrack([])
        return res
```

>1. **明确问题的“选择列表”**：每一步有哪些可选选项？（如全排列中未使用的数字）。
>2. **定义“路径”和“状态”**：如何记录当前已做的选择？（如`path`数组、`used`标记）。
>3. **确定终止条件**：何时停止递归？（如找到解、无法继续选择）。
>4. **设计剪枝策略**：如何提前排除无效路径？（如约束条件检查）

## 十二、图搜索 BFS ＆ DFS

### 12.1 深度优先搜索（Depth-First Search, DFS）

**深度优先搜索** 是一种**沿着路径尽可能深地探索**的图遍历算法。其核心逻辑是：从起始节点出发，优先访问当前节点的**未访问过的邻接节点**，并沿着这条路径一直走下去，直到无法继续（遇到已访问的节点或边界），然后回溯到上一个节点，继续探索其他未访问的邻接节点。

**应用场景：**

- **图/树的遍历**：如二叉树的前序、中序、后序遍历（本质是DFS的变种）。
- **路径搜索**：寻找两点间的任意路径（不要求最短）。
- **连通性问题**：判断图中是否存在从起点到终点的路径。
- **回溯问题**：如八皇后、全排列（DFS+剪枝）。

> DFS 通常通过栈（Stack）结构实现，每次弹出栈顶节点，压入其未访问的邻接节点。

### 12.2 广度优先搜索（Breadth-First Search, BFS）

**广度优先搜索** 是一种**逐层扩展**的图遍历算法。其核心逻辑是：从起始节点出发，先访问当前节点的**所有未访问过的邻接节点**（第一层），再依次访问这些邻接节点的邻接节点（第二层），以此类推，直到遍历完所有可达节点。

**应用场景：**

- **最短路径问题**：在无权图中寻找两点间的最短路径（BFS的层级特性天然保证）。
- **社交网络关系**：查找“朋友的朋友”（一级、二级关系）。
- **连通分量**：统计图中连通分量的数量（如岛屿问题）。
- **层序遍历**：二叉树的层序遍历（本质是BFS的变种）。

>BFS 通常通过队列（Queue）结构实现，确保按层级顺序访问节点。

|    **维度**    |            **DFS**             |             **BFS**              |
| :------------: | :----------------------------: | :------------------------------: |
|  **遍历顺序**  | 深度优先（一条路走到底，回溯） | 广度优先（逐层扩展，按层级访问） |
|  **数据结构**  |    栈（递归隐式栈/显式栈）     |           队列（FIFO）           |
| **空间复杂度** |  与递归深度相关（最坏 O(n)）   |  与层级节点数相关（最坏 O(n)）   |
|  **最短路径**  |      无法保证找到最短路径      |     无权图中天然保证最短路径     |
|  **适用问题**  |    路径存在性、回溯、连通性    |   最短路径、层级关系、连通分量   |
|  **内存消耗**  |  较低（栈深度取决于路径长度）  |     较高（队列存储层级节点）     |

### 12.3 替换字母

**问题描述：**给你一个矩阵 $matrix$，里面只包含字母 `'O'` 和 `'X'`，如果一个 `'O'` 上下左右四周都被 `'X'` 包围，那么这个 `'O'` 会被替换成 `'X'`。请你实现这一过程。

**代码：**

```python
class Solution:
    def replaceLetters(self, matrix: List[List[str]]) -> List[List[str]]:
        # 边界条件
        if not matrix or not matrix[0]:
            return matrix
        
        m, n = len(matrix), len(matrix[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # 深度优先遍历
        def dfs(i, j) -> bool:
            for dx, dy in directions:
                nx, ny = i + dx, j + dy
                # 检查是否越界或者不是 'X'
                if nx < 0 or nx >= m or ny < 0 or ny >=n or matrix[nx][ny] != 'X':
                    return False
            return True
        
        # 第一步：将需要替换的'O'标记为临时字符
        TEMP = '#'  # 临时标记
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 'O' and dfs(i, j):
                    matrix[i][j] = TEMP
                    
        # 第二步：将临时标记替换为'X'
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == TEMP:
                    matrix[i][j] = 'X'

        return matrix
```

### 12.4 最短路径

**问题描述：**给定一个迷宫，其中 `0` 表示可能通过的地方，`1` 表示墙壁。请问，从左上角走到右下角的最短路径是怎么样的？请依次输出路径上的点。

**代码：**

```python
class Solution:
    def shortestPath(self, maze: List[List[int]]) -> List[List[int]]:
        # 边界条件
        if not maze or not maze[0]:
            return []

        m, n = len(maze), len(maze[0])
        if maze[0][0] == 1 or maze[m-1][n-1] == 1:
            return []  # 起点或终点是墙壁n
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        queue = deque()
        queue.append((0, 0, [(0, 0)]))  # (x, y, path)
        visited = set()
        visited.add((0, 0))
        
        # BFS 标记
        while queue:    
            x, y, path = queue.popleft()
            
            # 到达终点
            if x == m-1 and y == n-1:
                return path
            
            # 遍历四个方向
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                # 判断是否越界
                if not (0 <= nx < m and 0 <= ny < n):
                    continue
                # 判断是否是墙壁
                if maze[nx][ny] == 0 and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    new_path = path + [(nx, ny)]
                    queue.append((nx, ny, new_path))
        
        return []
```

### 12.5 最安全的路径

**问题描述：**在一个无向图上，给定点个数 $n$，编号从 $0 \sim n$，再给定边的个数 $m$。其中每条边由$x[i]$, $y[i]$, $w[i]$ 表示。$x[i]$, $y[i]$ 表示这条边连接的 2 个点的编号，$w[i]$ 表示这条边的危险系数。

现在我们想找到一条路径从 $0 \sim n$，使得这条路径上最大危险系数最小。（注意：不是路径和，而是路径上的最大值最小）

**代码：**

```python
 class Solution:
    def minMaxDanger(self, n: int, edges: List[List[int]]) -> int:
        # 初始化邻接表
        adj = [[] for _ in range(n + 1)]
        for x, y, w in edges:
            adj[x].append((y, w))
            adj[y].append((x, w))
        
        # 初始化 max_w 和优先队列
        max_w = [float('inf')] * (n + 1)
        max_w[0] = 0
        heap = []
        heapq.heappush(heap, (0, 0)) # (当前危险系数, 当前节点)

        # Dijkstra 算法
        while heap:
            # 取出当前最大危险系数最小的节点
            curr_max, curr_node = heapq.heappop(heap)
            # 如果到达目标节点，返回当前路径的最大危险系数
            if curr_node == n:
                return curr_max
            
            # 如果当前路径的最大危险系数大于已知的最小值，跳过
            if curr_max > max_w[curr_node]:
                continue
            
            # 遍历当前节点的所有邻居
            for v, w in adj[curr_node]:
                # 计算经过当前边后的新路径最大危险系数
                new_max = max(curr_max, w)
                # 如果新路径的最大危险系数小于已知的最小值，更新并加入优先队列
                if new_max < max_w[v]:
                    max_w[v] = new_max
                    heapq.heappush(heap, (new_max, v))
                    
        # 如果没有找到路径，返回 -1
        return -1 
```

## 十三、动态规划 Dynamic Programming

动态规划是一种通过**分解问题为重叠子问题**，并**存储子问题的解以避免重复计算**的算法设计方法。其核心思想是“**分治+记忆化**”，通过解决子问题的最优解，逐步推导出原问题的最优解。

一个问题适合用动态规划解决，当且仅当满足以下两个条件：

1. **重叠子问题：**子问题会被多次重复计算。
2. **最优子结构：**原问题的最优解可通过子问题的最优解组合得到。

 **动态规划的关键要素在于找到问题中的状态和状态转移方程。**

>1. 识别问题的重叠子问题和最优子结构。
>2. 正确定义状态（如 `dp[i]`或 `dp[i][j]`的含义）。
>3. 推导状态转移方程（子问题如何组合成原问题）。

### 13.1 打劫

**问题描述：**你是一个专业的小偷，计划去沿街的住户家里偷盗。每间房内都藏有一定的现金，影响你偷盗的唯一制约元素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，要求你计算不触动报警装置的情况下，一夜之内能够偷窃到的最高金额。

**代码：**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 边界条件
        if not nums:
            return 0
        if len(nums) == 1:  
            return nums[0]

        # dp[i] 表示前i个房屋能偷到的最大金额
        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, len(nums)):
            # 最后一步：处理第 N 个房间
            # 如果选择偷 N 个房间，收益就是 dp[i-2] + nums[i]
            # 如果选择不偷 N 个房间，收益就是 dp[i-1]
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

        return dp[-1]
```

### 13.2 扰乱字符串

**问题描述：**使用下面描述的算法可以扰乱字符串 $s$ 得到字符串 $t$：

1. 如果字符串的长度为 1，算法停止；
2. 如果字符串的长度 > 1，执行下述步骤：
   - 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，其中 s = x + y 。
   - **随机** 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。

3. 在 x 和 y 这两个子字符串上继续从步骤 2 开始递归执行算法。

给你两个 **长度相等** 的字符串 $s_1$ 和 $s_2$，判断 $s_2$ 是否是 $s_1$ 的扰乱字符串。如果是，返回 $true $；否则，返回 $false $。

**代码：**

```python
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        # 边界条件 1：如果两个字符串相等，直接返回
        if s1 == s2:
            return True
        # 边界条件 2：如果两个字符串不相等，直接返回
        if len(s1) != len(s2):
            return False
        # 边界条件 3：如果两个字符串的字符种类和数量不相等，直接返回
        if sorted(s1) != sorted(s2):
            return False
        # 边界条件 4：如果两个字符串的长度为1，且两个字符串相等
        if len(s1) == 1 and s1 == s2:
            return True
        
        # 三维 DP
        n = len(s1)
        dp = [[[False for _ in range(n+1)
        ] for _ in range(n)] for _ in range(n)]

        # 初始化 dp 数组
        for i in range(n):
            for j in range(n):
                dp[i][j][1] = s1[i] == s2[j]
                
        # 状态转移方程：
        # dp[i][j][length] 表示 s1[i:i+length] 是否是 s2[j:j+length] 的扰乱字符串
        # 如果 s1[i:i+k] -> s2[j:j+k] 且 s1[i+k:i+length] -> s2[j+k:j+length]，则 dp[i][j][length] = True
        # 如果 s1[i:i+k] -> s2[j+length-k:j+length] 且 s1[i+k:i+length] -> s2[j:j+length-k]，则 dp[i][j][length] = True
        # 其中 k 是分割点

        # 遍历 dp 数组
        for length in range(2, n+1):
            # 遍历 s1 的起始位置
            for i in range(n-length+1):
                # 遍历 s2 的起始位置
                for j in range(n-length+1):
                    # 遍历分割点
                    for k in range(1, length):
                        # 情况1：没有交换位置
                        # s1[i:i+k] -> s2[j:j+k] 且 s1[i+k:i+length] -> s2[j+k:j+length]
                        if dp[i][j][k] and dp[i+k][j+k][length-k]:
                            dp[i][j][length] = True
                            break
                        # 情况2：交换位置
                        # s1[i:i+k] -> s2[j+length-k:j+length] 且 s1[i+k:i+length] -> s2[j:j+length-k]
                        if dp[i][j+length-k][k] and dp[i+k][j][length-k]:
                            dp[i][j][length] = True
                            break
                        
        return dp[0][0][n]
```

### 13.3 分割等和子集

**问题描述：**一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意：**

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

代码：

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # 边界条件
        if not nums:
            return False
        if len(nums) == 1:
            return False
        
        # 计算数组的总和
        total = sum(nums)
        # 如果总和是奇数，则不可能分割成两个和相等的子集
        if total % 2 != 0:
            return False
        
        # 目标和为总和的一半
        target = total // 2
        # 创建dp数组，dp[i] 表示能否凑成和为 i
        # 状态转移方程：dp[i] = dp[i] or dp[i - num]
        dp = [False] * (target + 1)
        # 初始化 dp[0] 为True，因为和为 0 一定可以凑成
        dp[0] = True

        # 遍历数组中的每一个元素
        for num in nums:
            # 从后往前遍历，防止重复使用同一个元素
            for i in range(target, num - 1, -1):
                # 更新dp数组
                dp[i] = dp[i] or dp[i - num]

        # 返回dp[target]的值
        return dp[target]
```

### 13.4 二叉树抢劫

**问题描述：**有一个地区只有一个入口，我们称为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。

如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额

**代码：**

```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        # 边界条件
        if not root:
            return 0
        
        def postOrder(node: TreeNode):
            if not node:
                return [0, 0]
            
            left = postOrder(node.left)
            right = postOrder(node.right)

            # 如果不偷当前节点，那么左右子节点都可以偷
            rob = node.val + left[1] + right[1]
            # 如果要偷当前节点，那么左右子节点就不能偷
            not_rob = max(left) + max(right)
            
            return [rob, not_rob]

        return max(postOrder(root))
```

### 13.5 N 次操作的最大分数和

**问题描述：**给你一个数组 $nums$，它是一个大小为 $2 \times n$ 的正整数数组。你必须对这个数组执行 $n$ 次操作。在第 $i$ 次 操作时（编号从 `1` 开始），你需要：

1. 选择两个元素 $x$ 和 $y$；
2. 获得分数 $i \times gcd(x,y)$；
3. 将 $x$ 和 $y$ 从 $nums$ 中删除；

请你返回 $n$  次操作后你能获得的分数和最大为多少。函数 $gcd(x,y)$ 是 $x$ 和 $y$ 的最大公约数。

**代码：**

```python
class Solution:
    def maxScore(self, nums: List[int]) -> int:
        # 边界条件
        if len(nums) < 2:
            return 0
    
        # 动态规划初始化
        n = len(nums) // 2  # 需要选择的对数
        # dp[i][mask]表示已经选出i对数字，且选中数字的状态为mask时的最大得分
        # mask是一个二进制数，每一位表示对应位置的数字是否被选中
        # 例如，mask=1010(二进制)表示第1和第3个数字被选中
        dp = [[0] * (1 << (2 * n)) for _ in range(n + 1)]
        
        # 动态规划过程
        # 外层循环：当前选择第几对数字（从1到n）
        for i in range(1, n + 1):
            # 中层循环：遍历所有可能的mask状态
            for mask in range(1 << (2 * n)):
                # 计算当前mask中1的个数（即已经选中的数字数量）
                cnt = bin(mask).count('1')
                # 如果当前选中的数字数量不等于2i（因为每对需要2个数字），则跳过
                if cnt != 2 * i:
                    continue
                
                # 内层循环：遍历所有可能的数字对(j,k)
                for j in range(2 * n):
                    # 如果第j个数字没有被选中，则跳过
                    if mask & (1 << j):
                        for k in range(j + 1, 2 * n):
                            # 如果第k个数字没有被选中，则跳过
                            if mask & (1 << k):
                                # 计算选择j和k这对数字的得分
                                # 1. 计算不包含j和k的mask状态：mask ^ (1 << j) ^ (1 << k)
                                # 2. 获取前i-1对数字的得分：dp[i-1][mask_without_j_and_k]
                                # 3. 计算当前对的得分：i * gcd(nums[j], nums[k])
                                # 4. 更新当前状态的得分
                                dp[i][mask] = max(
                                    dp[i][mask], 
                                    dp[i - 1][mask ^ (1 << j) ^ (1 << k)] + i * gcd(nums[j], nums[k])
                                )
        # 返回结果：选择了n对数字且所有数字都被选中的最大得分
        # (1 << (2 * n)) - 1 表示所有数字都被选中的mask状态
        return dp[n][(1 << (2 * n)) - 1]
```







